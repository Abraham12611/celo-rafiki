"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasicDataWrapper = exports.NoStorageProvider = exports.NoStorageRootProvidedData = exports.InvalidSignature = exports.FetchError = exports.OffchainErrorTypes = void 0;
const address_1 = require("@celo/base/lib/address");
const result_1 = require("@celo/base/lib/result");
const types_1 = require("@celo/contractkit/lib/identity/claims/types");
const metadata_1 = require("@celo/contractkit/lib/identity/metadata");
const address_2 = require("@celo/utils/lib/address");
const ecdh_1 = require("@celo/utils/lib/ecdh");
const signatureUtils_1 = require("@celo/utils/lib/signatureUtils");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const debug_1 = __importDefault(require("debug"));
const authorized_signer_1 = require("./offchain/accessors/authorized-signer");
const utils_1 = require("./offchain/utils");
const debug = (0, debug_1.default)('offchaindata');
var OffchainErrorTypes;
(function (OffchainErrorTypes) {
    OffchainErrorTypes["FetchError"] = "FetchError";
    OffchainErrorTypes["InvalidSignature"] = "InvalidSignature";
    OffchainErrorTypes["NoStorageRootProvidedData"] = "NoStorageRootProvidedData";
    OffchainErrorTypes["NoStorageProvider"] = "NoStorageProvider";
})(OffchainErrorTypes || (exports.OffchainErrorTypes = OffchainErrorTypes = {}));
class FetchError extends result_1.RootError {
    constructor(error) {
        super(OffchainErrorTypes.FetchError);
        this.message = error.message;
    }
}
exports.FetchError = FetchError;
class InvalidSignature extends result_1.RootError {
    constructor() {
        super(OffchainErrorTypes.InvalidSignature);
    }
}
exports.InvalidSignature = InvalidSignature;
class NoStorageRootProvidedData extends result_1.RootError {
    constructor() {
        super(OffchainErrorTypes.NoStorageRootProvidedData);
    }
}
exports.NoStorageRootProvidedData = NoStorageRootProvidedData;
class NoStorageProvider extends result_1.RootError {
    constructor() {
        super(OffchainErrorTypes.NoStorageProvider);
    }
}
exports.NoStorageProvider = NoStorageProvider;
class BasicDataWrapper {
    constructor(self, kit, signer) {
        this.self = self;
        this.kit = kit;
        this.readDataFrom = (0, result_1.makeAsyncThrowable)(this.readDataFromAsResult.bind(this));
        this.signer = signer || self;
    }
    readDataFromAsResult(account, dataPath, checkOffchainSigners, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.kit.contracts.getAccounts();
            const metadataURL = yield accounts.getMetadataURL(account);
            debug({ account, metadataURL });
            const metadata = yield metadata_1.IdentityMetadataWrapper.fetchFromURL(accounts, metadataURL);
            // TODO: Filter StorageRoots with the datapath glob
            const storageRoots = metadata
                .filterClaims(types_1.ClaimTypes.STORAGE)
                .map((_) => new StorageRoot(this, account, _.address));
            if (storageRoots.length === 0) {
                return (0, result_1.Err)(new NoStorageRootProvidedData());
            }
            const results = yield Promise.all(storageRoots.map((s) => __awaiter(this, void 0, void 0, function* () { return s.readAndVerifySignature(dataPath, checkOffchainSigners, type); })));
            const item = results.find((s) => s.ok);
            if (item === undefined) {
                return (0, result_1.Err)(new NoStorageRootProvidedData());
            }
            return item;
        });
    }
    writeDataTo(data, signature, dataPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.storageWriter === undefined) {
                return new NoStorageProvider();
            }
            try {
                yield Promise.all([
                    this.storageWriter.write(data, dataPath),
                    this.storageWriter.write(signature, `${dataPath}.signature`),
                ]);
            }
            catch (e) {
                return new FetchError(e instanceof Error ? e : new Error(e));
            }
        });
    }
}
exports.BasicDataWrapper = BasicDataWrapper;
class StorageRoot {
    constructor(wrapper, account, root) {
        this.wrapper = wrapper;
        this.account = account;
        this.root = root;
    }
    readAndVerifySignature(dataPath, checkOffchainSigners, type) {
        return __awaiter(this, void 0, void 0, function* () {
            let dataResponse, signatureResponse;
            try {
                ;
                [dataResponse, signatureResponse] = yield Promise.all([
                    (0, cross_fetch_1.default)((0, utils_1.resolvePath)(this.root, dataPath)),
                    (0, cross_fetch_1.default)((0, utils_1.resolvePath)(this.root, `${dataPath}.signature`)),
                ]);
            }
            catch (error) {
                const fetchError = error instanceof Error ? error : new Error(error);
                return (0, result_1.Err)(new FetchError(fetchError));
            }
            if (!dataResponse.ok) {
                return (0, result_1.Err)(new FetchError(new Error(dataResponse.statusText)));
            }
            if (!signatureResponse.ok) {
                return (0, result_1.Err)(new FetchError(new Error(signatureResponse.statusText)));
            }
            const [dataBody, signatureBody] = yield Promise.all([
                dataResponse.arrayBuffer(),
                signatureResponse.arrayBuffer(),
            ]);
            const body = Buffer.from(dataBody);
            const signature = (0, address_1.ensureLeading0x)(Buffer.from(signatureBody).toString('hex'));
            const toParse = type ? JSON.parse(body.toString()) : body;
            const typedData = yield (0, utils_1.buildEIP712TypedData)(this.wrapper, dataPath, toParse, type);
            if ((0, signatureUtils_1.verifyEIP712TypedDataSigner)(typedData, signature, this.account)) {
                return (0, result_1.Ok)(body);
            }
            const accounts = yield this.wrapper.kit.contracts.getAccounts();
            if (yield accounts.isAccount(this.account)) {
                const keys = yield Promise.all([
                    accounts.getVoteSigner(this.account),
                    accounts.getValidatorSigner(this.account),
                    accounts.getAttestationSigner(this.account),
                    accounts.getDataEncryptionKey(this.account),
                ]);
                const dekAddress = keys[3] ? (0, address_2.publicKeyToAddress)((0, ecdh_1.ensureUncompressed)(keys[3])) : '0x0';
                const signers = [keys[0], keys[1], keys[2], dekAddress];
                if (signers.some((signer) => (0, signatureUtils_1.verifyEIP712TypedDataSigner)(typedData, signature, signer))) {
                    return (0, result_1.Ok)(body);
                }
                if (checkOffchainSigners) {
                    let guessedSigner;
                    try {
                        guessedSigner = (0, signatureUtils_1.recoverEIP712TypedDataSignerRsv)(typedData, signature);
                    }
                    catch (error) {
                        guessedSigner = (0, signatureUtils_1.recoverEIP712TypedDataSignerVrs)(typedData, signature);
                    }
                    const authorizedSignerAccessor = new authorized_signer_1.AuthorizedSignerAccessor(this.wrapper);
                    const authorizedSigner = yield authorizedSignerAccessor.readAsResult(this.account, guessedSigner);
                    if (authorizedSigner.ok) {
                        return (0, result_1.Ok)(body);
                    }
                }
            }
            return (0, result_1.Err)(new InvalidSignature());
        });
    }
}
