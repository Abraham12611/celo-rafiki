"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CircuitBreakerClient = exports.FetchError = exports.EncryptionError = exports.CircuitBreakerUnavailableError = exports.CircuitBreakerServiceError = exports.CircuitBreakerErrorTypes = exports.CircuitBreakerEndpoints = exports.CircuitBreakerKeyStatus = exports.VALORA_MAINNET_CIRCUIT_BREAKER_ENVIRONMENT = exports.VALORA_ALFAJORES_CIRCUIT_BREAKER_ENVIRONMENT = exports.BASE64_REGEXP = void 0;
const result_1 = require("@celo/base/lib/result");
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const crypto = __importStar(require("crypto"));
// eslint-disable-next-line no-useless-escape
exports.BASE64_REGEXP = /^(?:[A-Za-z0-9+\/]{4})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/;
exports.VALORA_ALFAJORES_CIRCUIT_BREAKER_ENVIRONMENT = {
    url: 'https://us-central1-celo-mobile-alfajores.cloudfunctions.net/circuitBreaker/',
    publicKey: `-----BEGIN PUBLIC KEY-----
MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEAsYkNg3iY1ha4KGCGvHLl
mOMKV63lq+WsHIgUGfEuyfOWEBetVux9gvQEEPYpKbHgVQrfcegp28LoZYehWZHC
dIHSACcW0SGZagSOFEgxVSY6MgZZjmbTdlUtLac2cvxIDx8qhkoBjWRWu4g5LfdW
9QA0tiM3dR/pmA8YWcIYtyjGY1zglA/YqHClKsDRY+dbhshfILfohdFsVNJ3CWLS
J4yGvVe78AE/WiaXISV5ol+bqve4QlxzbBLIV4s44YONCh18/YhmGHCuSn8yy1/0
q3YW7COaFEGd7m8VnV2rU/dFLKyF0XEanS6xk9ciL9uafR9dMryEQ7AW+yKmfQBG
H2i5uiKnWW2a3a873ShG2Qphl9mw1Kcrdxug4qk9y7RoKlMnG3Wdr4HMQb9S8KYf
07ZyVEbFip26ANWGo8dCA8fWvVtU5DByoWPI+PuglOB22z2noXov98imSFJfz9vu
yGAQt3CUOwUQvt+RObDXiHHIxJjU+6/81X3Jdnt3dFEfAgMBAAE=
-----END PUBLIC KEY-----`,
};
exports.VALORA_MAINNET_CIRCUIT_BREAKER_ENVIRONMENT = {
    url: 'https://us-central1-celo-mobile-mainnet.cloudfunctions.net/circuitBreaker/',
    publicKey: `-----BEGIN PUBLIC KEY-----
MIIBojANBgkqhkiG9w0BAQEFAAOCAY8AMIIBigKCAYEArQ89m/HIGECXR7ceZZRS
b6MZEw1S1o5qgi6sLEejBMUQhM/wgySoo5ydiW7S4iyiqEksQNAlOs5Mrv1aE9Ul
bG+rpglOA1xYLyjY7xUZE2tyPksPXcSKgu6d+G9gVtbmFld1Kr0jVx4qOLejtH3S
dGbX6g9GshgB1W4iEDZ4qEJBuvItSTudK3BFM1mBfEq1w3kDxNzYKC1zFlw+DWWh
BgIPB7zEp+MJNTwel2z7H02wsEMJMXzKwaAWaDp8PYfF3RwgCDIFkf+QteYIEUrG
C9bFhdYpDGY9Ldiz7kca9G9dvXWpZUQOYyOY7CFx0k2XcTBwx4Lq524lNR8waIDu
OT5jj2SIwXf5eKtyFMUqRNnqgs+IHHcWgh0CH7mfhPlFBMivKlwHgQqCJH3rHlgu
CMi3ENv4+p7+svshngntxGkEzZcLV3YVW7BG6xSOAqC1tjkM1PkmXENQOq+bxAL6
bg3W6cTRQAQxoicu6+1c5Tdb/K36TXx0mHan7/Z8JCqfAgMBAAE=
-----END PUBLIC KEY-----`,
};
var CircuitBreakerKeyStatus;
(function (CircuitBreakerKeyStatus) {
    CircuitBreakerKeyStatus["ENABLED"] = "ENABLED";
    CircuitBreakerKeyStatus["DISABLED"] = "DISABLED";
    CircuitBreakerKeyStatus["DESTROYED"] = "DESTROYED";
    CircuitBreakerKeyStatus["UNKNOWN"] = "UNKNOWN";
})(CircuitBreakerKeyStatus || (exports.CircuitBreakerKeyStatus = CircuitBreakerKeyStatus = {}));
var CircuitBreakerEndpoints;
(function (CircuitBreakerEndpoints) {
    CircuitBreakerEndpoints["HEALTH"] = "health";
    CircuitBreakerEndpoints["STATUS"] = "status";
    CircuitBreakerEndpoints["UNWRAP_KEY"] = "unwrap-key";
})(CircuitBreakerEndpoints || (exports.CircuitBreakerEndpoints = CircuitBreakerEndpoints = {}));
var CircuitBreakerErrorTypes;
(function (CircuitBreakerErrorTypes) {
    CircuitBreakerErrorTypes["FETCH_ERROR"] = "FETCH_ERROR";
    CircuitBreakerErrorTypes["SERVICE_ERROR"] = "CIRCUIT_BREAKER_SERVICE_ERROR";
    CircuitBreakerErrorTypes["UNAVAILABLE_ERROR"] = "CIRCUIT_BREAKER_UNAVAILABLE_ERROR";
    CircuitBreakerErrorTypes["ENCRYPTION_ERROR"] = "ENCRYPTION_ERROR";
})(CircuitBreakerErrorTypes || (exports.CircuitBreakerErrorTypes = CircuitBreakerErrorTypes = {}));
class CircuitBreakerServiceError extends result_1.RootError {
    constructor(status, error) {
        super(CircuitBreakerErrorTypes.SERVICE_ERROR);
        this.status = status;
        this.error = error;
    }
}
exports.CircuitBreakerServiceError = CircuitBreakerServiceError;
class CircuitBreakerUnavailableError extends result_1.RootError {
    constructor(status) {
        super(CircuitBreakerErrorTypes.UNAVAILABLE_ERROR);
        this.status = status;
    }
}
exports.CircuitBreakerUnavailableError = CircuitBreakerUnavailableError;
class EncryptionError extends result_1.RootError {
    constructor(error) {
        super(CircuitBreakerErrorTypes.ENCRYPTION_ERROR);
        this.error = error;
    }
}
exports.EncryptionError = EncryptionError;
class FetchError extends result_1.RootError {
    constructor(error) {
        super(CircuitBreakerErrorTypes.FETCH_ERROR);
        this.error = error;
    }
}
exports.FetchError = FetchError;
/**
 * Client for interacting with a circuit breaker service for encrypted cloud backups.
 *
 * @remarks A circuit breaker is a service supporting a public decryption function backed by an HSM
 * key. If the need arises, the circuit breaker operator may take the decryption function offline.
 * A client can encrypt data to the circuit breaker public key and store it in a non-public place.
 * This data will then be available under normal circumstances, but become unavailable in the case
 * of an emergency.
 *
 * It is intended for use in password-based key derivation when ODIS is used as a key hardening
 * function. Clients may include in their key dervivation a random value which they encrypt to the
 * circuit breaker public key. This allows the circuit breaker operator to disable key derivation,
 * by restricting access to the encrypted keying material, in the event that ODIS is conpromised.
 * This acts as a safety measure to allow wallet providers, or other users of ODIS key hardening, to
 * prevent attackers from being able to brute force their users' derived keys in the event that
 * ODIS is compromised such that it can no longer add to the key hardening.
 *
 * The circuit breaker service is designed for use in the encrypted cloud backup protocol. More
 * information about encrypted cloud backup and the circuit breaker service can be found in the
 * official {@link https://docs.celo.org/celo-codebase/protocol/identity/encrypted-cloud-backup |
 * Celo documentation}
 */
class CircuitBreakerClient {
    constructor(environment) {
        this.environment = environment;
    }
    url(endpoint) {
        // Note that if the result of this is an invalid URL, the URL constructor will throw. This is
        // caught and reported as a fetch error, as a request could not be made.
        return new URL(endpoint, this.environment.url).href;
    }
    /**
     * Check the current status of the circuit breaker service. Result will reflect whether or not
     * the circuit breaker keys are currently available.
     */
    status() {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            try {
                response = yield (0, cross_fetch_1.default)(this.url(CircuitBreakerEndpoints.STATUS), {
                    method: 'GET',
                    headers: {
                        Accept: 'application/json',
                    },
                });
            }
            catch (error) {
                return (0, result_1.Err)(new FetchError(error));
            }
            let obj;
            try {
                obj = yield response.json();
            }
            catch (error) {
                return (0, result_1.Err)(new CircuitBreakerServiceError(response.status, error));
            }
            // If the response was an error code, return an error to the user.
            // We do not expect an error message to be included with the response from the status endpoint.
            if (!response.ok) {
                return (0, result_1.Err)(new CircuitBreakerServiceError(response.status));
            }
            if (!Object.values(CircuitBreakerKeyStatus).includes(obj.status)) {
                return (0, result_1.Err)(new CircuitBreakerServiceError(response.status, new Error(`circuit breaker service returned unexpected response: ${obj.status}`)));
            }
            return (0, result_1.Ok)(obj.status);
        });
    }
    /**
     * RSA-OAEP-256 Encrypt the provided key value against the public key of the circuit breaker.
     *
     * @remarks Note that this is an entirely local procedure and does not require interaction with
     * the circuit breaker service. Encryption occurs only against the service public key.
     */
    wrapKey(plaintext) {
        let ciphertext;
        try {
            ciphertext = crypto.publicEncrypt({
                key: this.environment.publicKey,
                oaepHash: 'sha256',
            }, plaintext);
        }
        catch (error) {
            return (0, result_1.Err)(new EncryptionError(error));
        }
        return (0, result_1.Ok)(ciphertext);
    }
    /** Request the circuit breaker service to decrypt the provided encrypted key value */
    unwrapKey(ciphertext) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                ciphertext: ciphertext.toString('base64'),
            };
            let response;
            try {
                response = yield (0, cross_fetch_1.default)(this.url(CircuitBreakerEndpoints.UNWRAP_KEY), {
                    method: 'POST',
                    headers: {
                        Accept: 'application/json',
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(request),
                });
            }
            catch (error) {
                return (0, result_1.Err)(new FetchError(error));
            }
            let obj;
            try {
                obj = yield response.json();
            }
            catch (error) {
                return (0, result_1.Err)(new CircuitBreakerServiceError(response.status, error));
            }
            // If the response was an error code, return an error to the user after trying to parse the
            // error from the service response. Either an error message or a status value may be returned.
            if (!response.ok) {
                if (obj.error !== undefined || obj.status === undefined) {
                    return (0, result_1.Err)(new CircuitBreakerServiceError(response.status, obj.error));
                }
                else {
                    return (0, result_1.Err)(new CircuitBreakerUnavailableError(obj.status));
                }
            }
            const plaintext = obj.plaintext;
            if (plaintext === undefined || !exports.BASE64_REGEXP.test(plaintext)) {
                // Plaintext value is not returned in the error as it may has sensitive information.
                const error = new Error('circuit breaker returned invalid plaintext response');
                return (0, result_1.Err)(new CircuitBreakerServiceError(response.status, error));
            }
            return (0, result_1.Ok)(Buffer.from(plaintext, 'base64'));
        });
    }
}
exports.CircuitBreakerClient = CircuitBreakerClient;
