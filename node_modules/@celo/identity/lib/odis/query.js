"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendOdisDomainRequest = exports.queryOdis = exports.getOdisPnpRequestAuth = exports.signWithDEK = exports.getServiceContext = exports.OdisContextName = exports.OdisAPI = exports.ODIS_MAINNET_CONTEXT_DOMAINS = exports.ODIS_MAINNET_CONTEXT_PNP = exports.ODIS_ALFAJORES_CONTEXT_DOMAINS = exports.ODIS_ALFAJORES_CONTEXT_PNP = exports.ODIS_STAGING_CONTEXT = exports.ErrorMessages = exports.signWithRawKey = exports.AuthenticationMethod = void 0;
const async_1 = require("@celo/base/lib/async");
const phone_number_privacy_common_1 = require("@celo/phone-number-privacy-common");
Object.defineProperty(exports, "AuthenticationMethod", { enumerable: true, get: function () { return phone_number_privacy_common_1.AuthenticationMethod; } });
Object.defineProperty(exports, "signWithRawKey", { enumerable: true, get: function () { return phone_number_privacy_common_1.signWithRawKey; } });
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const debug_1 = __importDefault(require("debug"));
const Either_1 = require("fp-ts/lib/Either");
const debug = (0, debug_1.default)('kit:odis:query');
var ErrorMessages;
(function (ErrorMessages) {
    ErrorMessages["ODIS_QUOTA_ERROR"] = "odisQuotaError";
    ErrorMessages["ODIS_RATE_LIMIT_ERROR"] = "odisRateLimitError";
    ErrorMessages["ODIS_INPUT_ERROR"] = "odisBadInputError";
    ErrorMessages["ODIS_AUTH_ERROR"] = "odisAuthError";
    ErrorMessages["ODIS_CLIENT_ERROR"] = "Unknown Client Error";
    ErrorMessages["ODIS_FETCH_ERROR"] = "odisFetchError";
    ErrorMessages["ODIS_RESPONSE_ERROR"] = "odisResponseError";
})(ErrorMessages || (exports.ErrorMessages = ErrorMessages = {}));
exports.ODIS_STAGING_CONTEXT = {
    odisUrl: 'https://odis-combiner-staging.integration-tests.celo-networks-dev.org',
    odisPubKey: '7FsWGsFnmVvRfMDpzz95Np76wf/1sPaK0Og9yiB+P8QbjiC8FV67NBans9hzZEkBaQMhiapzgMR6CkZIZPvgwQboAxl65JWRZecGe5V3XO4sdKeNemdAZ2TzQuWkuZoA',
};
exports.ODIS_ALFAJORES_CONTEXT_PNP = {
    odisUrl: 'https://odis-combiner-alfajores.alfajores.celo-testnet.org',
    odisPubKey: 'kPoRxWdEdZ/Nd3uQnp3FJFs54zuiS+ksqvOm9x8vY6KHPG8jrfqysvIRU0wtqYsBKA7SoAsICMBv8C/Fb2ZpDOqhSqvr/sZbZoHmQfvbqrzbtDIPvUIrHgRS0ydJCMsA',
};
exports.ODIS_ALFAJORES_CONTEXT_DOMAINS = {
    odisUrl: 'https://odis-combiner-alfajores.alfajores.celo-testnet.org',
    odisPubKey: '+ZrxyPvLChWUX/DyPw6TuGwQH0glDJEbSrSxUARyP5PuqYyP/U4WZTV1e0bAUioBZ6QCJMiLpDwTaFvy8VnmM5RBbLQUMrMg5p4+CBCqj6HhsMfcyUj8V0LyuNdStlCB',
};
exports.ODIS_MAINNET_CONTEXT_PNP = {
    odisUrl: 'https://odis-combiner-mainnet.rc1-europe-west1.celo-testnet.org',
    odisPubKey: 'FvreHfLmhBjwxHxsxeyrcOLtSonC9j7K3WrS4QapYsQH6LdaDTaNGmnlQMfFY04Bp/K4wAvqQwO9/bqPVCKf8Ze8OZo8Frmog4JY4xAiwrsqOXxug11+htjEe1pj4uMA',
};
exports.ODIS_MAINNET_CONTEXT_DOMAINS = {
    odisUrl: 'https://odis-combiner-mainnet.rc1-europe-west1.celo-testnet.org',
    odisPubKey: 'LX4tLiuYm8geZ3ztmH7oIWz4ohXt3ePRTd9BbG9RO86NMrApflioiOzKYtIsyjEA0uarnX8Emo+luTY4bwEWpgZDyPYE6UMWAoBaZBdy6NDMgAxSbdNtaQEq51fBjCUA',
};
var OdisAPI;
(function (OdisAPI) {
    OdisAPI["PNP"] = "pnp";
    OdisAPI["DOMAIN"] = "domain";
})(OdisAPI || (exports.OdisAPI = OdisAPI = {}));
var OdisContextName;
(function (OdisContextName) {
    OdisContextName["STAGING"] = "alfajoresstaging";
    OdisContextName["ALFAJORES"] = "alfajores";
    OdisContextName["MAINNET"] = "mainnet";
})(OdisContextName || (exports.OdisContextName = OdisContextName = {}));
function getServiceContext(contextName = OdisContextName.MAINNET, api = OdisAPI.PNP) {
    switch (contextName) {
        case OdisContextName.ALFAJORES:
            return {
                [OdisAPI.PNP]: exports.ODIS_ALFAJORES_CONTEXT_PNP,
                [OdisAPI.DOMAIN]: exports.ODIS_ALFAJORES_CONTEXT_DOMAINS,
            }[api];
        case OdisContextName.STAGING:
            return {
                // Intentionally the same on staging
                [OdisAPI.PNP]: exports.ODIS_STAGING_CONTEXT,
                [OdisAPI.DOMAIN]: exports.ODIS_STAGING_CONTEXT,
            }[api];
        case OdisContextName.MAINNET:
            return {
                [OdisAPI.PNP]: exports.ODIS_MAINNET_CONTEXT_PNP,
                [OdisAPI.DOMAIN]: exports.ODIS_MAINNET_CONTEXT_DOMAINS,
            }[api];
        default:
            return exports.ODIS_MAINNET_CONTEXT_PNP;
    }
}
exports.getServiceContext = getServiceContext;
function signWithDEK(msg, signer) {
    return (0, phone_number_privacy_common_1.signWithRawKey)(msg, signer.rawKey);
}
exports.signWithDEK = signWithDEK;
function getOdisPnpRequestAuth(body, signer) {
    return __awaiter(this, void 0, void 0, function* () {
        // Sign payload using provided account and authentication method.
        const bodyString = JSON.stringify(body);
        if (signer.authenticationMethod === phone_number_privacy_common_1.AuthenticationMethod.ENCRYPTION_KEY) {
            return signWithDEK(bodyString, signer);
        }
        if (signer.authenticationMethod === phone_number_privacy_common_1.AuthenticationMethod.WALLET_KEY) {
            return signer.contractKit.connection.sign(bodyString, body.account);
        }
        throw new Error('AuthenticationMethod not supported');
    });
}
exports.getOdisPnpRequestAuth = getOdisPnpRequestAuth;
/**
 * Send any OdisRequest to the specified CombinerEndpoint for the given ServiceContext
 *
 * @param body OdisRequest to send in the body of the HTTP request.
 * @param context Contains service URL and public to determine which instance to contact.
 * @param endpoint Endpoint to query
 * @param responseSchema io-ts schema to ensure type safety of responses
 * @param headers custom request headers corresponding to the type of OdisRequest (keyVersion, Authentication, etc.)
 */
function queryOdis(body, context, endpoint, responseSchema, headers, abortController) {
    return __awaiter(this, void 0, void 0, function* () {
        debug(`Posting to ${endpoint}`);
        const dontRetry = [
            ErrorMessages.ODIS_QUOTA_ERROR,
            ErrorMessages.ODIS_RATE_LIMIT_ERROR,
            ErrorMessages.ODIS_AUTH_ERROR,
            ErrorMessages.ODIS_INPUT_ERROR,
            ErrorMessages.ODIS_CLIENT_ERROR,
        ];
        return (0, async_1.selectiveRetryAsyncWithBackOff)(() => __awaiter(this, void 0, void 0, function* () {
            let res;
            try {
                res = yield (0, cross_fetch_1.default)(context.odisUrl + endpoint, {
                    method: 'POST',
                    headers: Object.assign({ Accept: 'application/json', 'Content-Type': 'application/json' }, headers),
                    body: JSON.stringify(body),
                    signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
                });
            }
            catch (error) {
                throw new Error(`${ErrorMessages.ODIS_FETCH_ERROR}: ${error}`);
            }
            if (res.ok) {
                debug('Response ok. Parsing.');
                const response = yield res.json();
                // Verify that the response is the type we expected, then return it.
                const decoding = responseSchema.decode(response);
                if ((0, Either_1.isLeft)(decoding)) {
                    throw new Error(ErrorMessages.ODIS_RESPONSE_ERROR);
                }
                return decoding.right;
            }
            debug(`Response not okay. Status ${res.status}`);
            switch (res.status) {
                case 403:
                    throw new Error(ErrorMessages.ODIS_QUOTA_ERROR);
                case 429:
                    throw new Error(ErrorMessages.ODIS_RATE_LIMIT_ERROR);
                case 400:
                    throw new Error(ErrorMessages.ODIS_INPUT_ERROR);
                case 401:
                    throw new Error(ErrorMessages.ODIS_AUTH_ERROR);
                default:
                    if (res.status >= 400 && res.status < 500) {
                        // Don't retry error codes in 400s
                        throw new Error(`${ErrorMessages.ODIS_CLIENT_ERROR} ${res.status}`);
                    }
                    throw new Error(`Unknown failure ${res.status}`);
            }
        }), 3, dontRetry, []);
    });
}
exports.queryOdis = queryOdis;
/**
 * Send the given domain request to ODIS (e.g. to get a POPRF evaluation or check quota).
 *
 * @param body Request to send in the body of the HTTP request.
 * @param context Contains service URL and public to determine which instance to contact.
 * @param endpoint Endpoint to query (e.g. '/domain/sign', '/domain/quotaStatus').
 * @param responseSchema io-ts type for the expected response type. Provided to ensure type safety.
 * @param headers optional header fields relevant to the given request type (keyVersion, Authentication, etc.)
 */
function sendOdisDomainRequest(body, context, endpoint, responseSchema, headers) {
    return __awaiter(this, void 0, void 0, function* () {
        return queryOdis(body, context, endpoint, responseSchema, headers);
    });
}
exports.sendOdisDomainRequest = sendOdisDomainRequest;
