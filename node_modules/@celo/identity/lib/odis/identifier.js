"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPepperFromThresholdSignature = exports.getIdentifierHash = exports.getObfuscatedIdentifierFromSignature = exports.getBlindedIdentifierSignature = exports.getBlindedIdentifier = exports.getObfuscatedIdentifier = exports.getPrefixedIdentifier = exports.IdentifierPrefix = void 0;
const phoneNumbers_1 = require("@celo/base/lib/phoneNumbers");
const odis_identifiers_1 = require("@celo/odis-identifiers");
Object.defineProperty(exports, "IdentifierPrefix", { enumerable: true, get: function () { return odis_identifiers_1.IdentifierPrefix; } });
Object.defineProperty(exports, "getPrefixedIdentifier", { enumerable: true, get: function () { return odis_identifiers_1.getPrefixedIdentifier; } });
const phone_number_privacy_common_1 = require("@celo/phone-number-privacy-common");
const solidity_1 = require("@celo/utils/lib/solidity");
const crypto_1 = require("crypto");
const debug_1 = __importDefault(require("debug"));
const bls_blinding_client_1 = require("./bls-blinding-client");
const query_1 = require("./query");
const debug = (0, debug_1.default)('kit:odis:identifier');
const sha3 = (v) => (0, solidity_1.soliditySha3)({ type: 'string', value: v });
const PEPPER_CHAR_LENGTH = 13;
/**
 * Retrieve the obfuscated identifier for the provided plaintext identifier
 * Performs blinding, querying, and unblinding
 *
 * @remarks This function will send a request to ODIS, authorized by the provided signer.
 * This method consumes ODIS quota on the account provided by the signer.
 * You can use the DEK as your signer to decrease quota usage
 *
 * @param plaintextIdentifier Off-chain identifier, ex: phone number, twitter handle, email, etc.
 * @param identifierPrefix Standardized prefix used to prevent collisions between identifiers
 * @param account The address making the request to ODIS, from which quota will be charged
 * @param signer Object containing the private key used to authenticate the ODIS request
 * @param context Specifies which ODIS combiner url should be queried (i.e. mainnet or alfajores)
 * @param blindingFactor Optional Private seed used to blind identifers before they are sent to ODIS
 * @param clientVersion Optional Specifies the client software version
 * @param blsBlindingClient Optional Performs blinding and unblinding, defaults to WasmBlsBlindingClient
 * @param sessionID Optional Used to track user sessions across the client and ODIS
 * @param keyVersion Optional For testing. Specifies which version key ODIS should use
 * @param abortController Optional Allows client to specify a timeout for the ODIS request
 */
function getObfuscatedIdentifier(plaintextIdentifier, identifierPrefix, account, signer, context, blindingFactor, clientVersion, blsBlindingClient, sessionID, keyVersion, abortController) {
    return __awaiter(this, void 0, void 0, function* () {
        debug('Getting identifier pepper');
        let seed;
        if (blindingFactor) {
            seed = Buffer.from(blindingFactor);
        }
        else if (signer.authenticationMethod === query_1.AuthenticationMethod.ENCRYPTION_KEY) {
            seed = Buffer.from(signer.rawKey);
        }
        // Fallback to using Wasm version if not specified
        if (!blsBlindingClient) {
            debug('No BLSBlindingClient found, using WasmBlsBlindingClient');
            blsBlindingClient = new bls_blinding_client_1.WasmBlsBlindingClient(context.odisPubKey);
        }
        const base64BlindedMessage = yield getBlindedIdentifier(plaintextIdentifier, identifierPrefix, blsBlindingClient, seed);
        const base64BlindSig = yield getBlindedIdentifierSignature(account, signer, context, base64BlindedMessage, clientVersion, sessionID, keyVersion, abortController);
        return getObfuscatedIdentifierFromSignature(plaintextIdentifier, identifierPrefix, base64BlindSig, blsBlindingClient);
    });
}
exports.getObfuscatedIdentifier = getObfuscatedIdentifier;
/**
 * Blinds the plaintext identifier in preparation for the ODIS request
 *
 * @remarks Caller should use the same blsBlindingClient instance for unblinding
 *
 * @param plaintextIdentifier Off-chain identifier, ex: phone number, twitter handle, email, etc.
 * @param identifierPrefix Standardized prefix used to prevent collisions between identifiers
 * @param blsBlindingClient Optional Performs blinding and unblinding, defaults to WasmBlsBlindingClient
 * @param seed Optional Buffer generated from the blindingFactor, if provided
 */
function getBlindedIdentifier(plaintextIdentifier, identifierPrefix, blsBlindingClient, seed) {
    return __awaiter(this, void 0, void 0, function* () {
        debug('Retrieving blinded message');
        // phone number identifiers don't have prefixes in the blinding stage
        // to maintain backwards compatibility wih ASv1
        let identifier = (0, odis_identifiers_1.getPrefixedIdentifier)(plaintextIdentifier, identifierPrefix);
        if (identifierPrefix === odis_identifiers_1.IdentifierPrefix.PHONE_NUMBER) {
            if (!(0, phoneNumbers_1.isE164Number)(plaintextIdentifier)) {
                throw new Error(`Invalid phone number: ${plaintextIdentifier}`);
            }
            identifier = plaintextIdentifier;
        }
        return blsBlindingClient.blindMessage(Buffer.from(identifier).toString('base64'), seed);
    });
}
exports.getBlindedIdentifier = getBlindedIdentifier;
/**
 * Query ODIS for the blinded signature
 *
 * @remarks
 * Response can be passed into getObfuscatedIdentifierFromSignature
 * to retrieve the obfuscated identifier
 *
 * @param account The address making the request to ODIS, from which quota will be charged
 * @param signer Object containing the private key used to authenticate the ODIS request
 * @param context Specifies which ODIS combiner url should be queried (i.e. mainnet or alfajores)
 * @param base64BlindedMessage The blinded prefixed identifier to be sent to ODIS
 * @param clientVersion Optional Specifies the client software version
 * @param sessionID Optional Used to track user sessions across the client and ODIS
 * @param keyVersion Optional For testing. Specifies which version key ODIS should use
 * @param abortController Optional Allows client to specify a timeout for the ODIS request
 */
function getBlindedIdentifierSignature(account, signer, context, base64BlindedMessage, clientVersion, sessionID, keyVersion, abortControlller) {
    return __awaiter(this, void 0, void 0, function* () {
        const body = {
            account,
            blindedQueryPhoneNumber: base64BlindedMessage,
            version: clientVersion,
            authenticationMethod: signer.authenticationMethod,
            sessionID,
        };
        const response = yield (0, query_1.queryOdis)(body, context, phone_number_privacy_common_1.CombinerEndpointPNP.PNP_SIGN, phone_number_privacy_common_1.SignMessageResponseSchema, {
            [phone_number_privacy_common_1.KEY_VERSION_HEADER]: keyVersion === null || keyVersion === void 0 ? void 0 : keyVersion.toString(),
            Authorization: yield (0, query_1.getOdisPnpRequestAuth)(body, signer),
        }, abortControlller);
        if (!response.success) {
            throw new Error(response.error);
        }
        return response.signature;
    });
}
exports.getBlindedIdentifierSignature = getBlindedIdentifierSignature;
/**
 * Unblind the response and return the obfuscated identifier
 *
 * @param plaintextIdentifier Off-chain identifier, ex: phone number, twitter handle, email, etc.
 * @param identifierPrefix Standardized prefix used to prevent collisions between identifiers
 * @param base64BlindedSignature The blinded signed identifier returned by ODIS
 * @param blsBlindingClient Optional Performs blinding and unblinding, defaults to WasmBlsBlindingClient
 */
function getObfuscatedIdentifierFromSignature(plaintextIdentifier, identifierPrefix, base64BlindedSignature, blsBlindingClient) {
    return __awaiter(this, void 0, void 0, function* () {
        debug('Retrieving unblinded signature');
        const base64UnblindedSig = yield blsBlindingClient.unblindAndVerifyMessage(base64BlindedSignature);
        const sigBuf = Buffer.from(base64UnblindedSig, 'base64');
        debug('Converting sig to pepper');
        const pepper = getPepperFromThresholdSignature(sigBuf);
        const obfuscatedIdentifier = (0, exports.getIdentifierHash)(plaintextIdentifier, identifierPrefix, pepper);
        return {
            plaintextIdentifier,
            obfuscatedIdentifier,
            pepper,
            unblindedSignature: base64UnblindedSig,
        };
    });
}
exports.getObfuscatedIdentifierFromSignature = getObfuscatedIdentifierFromSignature;
/**
 * Generates final identifier that is published on-chain.
 *
 * @remarks
 * Concatenates the plaintext prefixed identifier with the pepper derived by hashing the unblinded
 * signature returned by ODIS.
 *
 * @param plaintextIdentifier Off-chain identifier, ex: phone number, twitter handle, email, etc.
 * @param identifierPrefix Standardized prefix used to prevent collisions between identifiers
 * @param pepper Hash of the unblinded signature returned by ODIS
 */
const getIdentifierHash = (plaintextIdentifier, identifierPrefix, pepper) => {
    return (0, odis_identifiers_1.getIdentifierHash)(sha3, plaintextIdentifier, identifierPrefix, pepper);
};
exports.getIdentifierHash = getIdentifierHash;
/**
 * This is the algorithm that creates a pepper from the unblinded message signatures
 * It simply hashes it with sha256 and encodes it to hex
 *
 * @remarks Currently uses 13 chars for a 78 bit pepper
 *
 * @param sigBuf Unblinded signature returned by ODIS
 */
function getPepperFromThresholdSignature(sigBuf) {
    return (0, crypto_1.createHash)('sha256').update(sigBuf).digest('base64').slice(0, PEPPER_CHAR_LENGTH);
}
exports.getPepperFromThresholdSignature = getPepperFromThresholdSignature;
