/// <reference types="node" />
import { Result, RootError } from '@celo/base/lib/result';
export declare const BASE64_REGEXP: RegExp;
export interface CircuitBreakerServiceContext {
    url: string;
    publicKey: string;
}
export declare const VALORA_ALFAJORES_CIRCUIT_BREAKER_ENVIRONMENT: CircuitBreakerServiceContext;
export declare const VALORA_MAINNET_CIRCUIT_BREAKER_ENVIRONMENT: CircuitBreakerServiceContext;
export declare enum CircuitBreakerKeyStatus {
    ENABLED = "ENABLED",
    DISABLED = "DISABLED",
    DESTROYED = "DESTROYED",
    UNKNOWN = "UNKNOWN"
}
export declare enum CircuitBreakerEndpoints {
    HEALTH = "health",
    STATUS = "status",
    UNWRAP_KEY = "unwrap-key"
}
export interface CircuitBreakerStatusResponse {
    /** Status of the circuit breaker service */
    status: CircuitBreakerKeyStatus;
}
export interface CircuitBreakerUnwrapKeyRequest {
    /** RSA-OAEP-256 encrypted data to be unwrapped by the circuit breaker. Encoded as base64 */
    ciphertext: string;
}
export interface CircuitBreakerUnwrapKeyResponse {
    /** Decryption of the ciphertext provided to the circuit breaker service */
    plaintext?: string;
    /** Error message indicating what went wrong if the ciphertext could not be decrypted */
    error?: string;
    /** Status of the circuit breaker service. Included if the service is not enabled. */
    status?: CircuitBreakerKeyStatus;
}
export declare enum CircuitBreakerErrorTypes {
    FETCH_ERROR = "FETCH_ERROR",
    SERVICE_ERROR = "CIRCUIT_BREAKER_SERVICE_ERROR",
    UNAVAILABLE_ERROR = "CIRCUIT_BREAKER_UNAVAILABLE_ERROR",
    ENCRYPTION_ERROR = "ENCRYPTION_ERROR"
}
export declare class CircuitBreakerServiceError extends RootError<CircuitBreakerErrorTypes.SERVICE_ERROR> {
    readonly status: number;
    readonly error?: Error | undefined;
    constructor(status: number, error?: Error | undefined);
}
export declare class CircuitBreakerUnavailableError extends RootError<CircuitBreakerErrorTypes.UNAVAILABLE_ERROR> {
    readonly status: CircuitBreakerKeyStatus;
    constructor(status: CircuitBreakerKeyStatus);
}
export declare class EncryptionError extends RootError<CircuitBreakerErrorTypes.ENCRYPTION_ERROR> {
    readonly error?: Error | undefined;
    constructor(error?: Error | undefined);
}
export declare class FetchError extends RootError<CircuitBreakerErrorTypes.FETCH_ERROR> {
    readonly error?: Error | undefined;
    constructor(error?: Error | undefined);
}
export type CircuitBreakerError = CircuitBreakerServiceError | CircuitBreakerUnavailableError | EncryptionError | FetchError;
/**
 * Client for interacting with a circuit breaker service for encrypted cloud backups.
 *
 * @remarks A circuit breaker is a service supporting a public decryption function backed by an HSM
 * key. If the need arises, the circuit breaker operator may take the decryption function offline.
 * A client can encrypt data to the circuit breaker public key and store it in a non-public place.
 * This data will then be available under normal circumstances, but become unavailable in the case
 * of an emergency.
 *
 * It is intended for use in password-based key derivation when ODIS is used as a key hardening
 * function. Clients may include in their key dervivation a random value which they encrypt to the
 * circuit breaker public key. This allows the circuit breaker operator to disable key derivation,
 * by restricting access to the encrypted keying material, in the event that ODIS is conpromised.
 * This acts as a safety measure to allow wallet providers, or other users of ODIS key hardening, to
 * prevent attackers from being able to brute force their users' derived keys in the event that
 * ODIS is compromised such that it can no longer add to the key hardening.
 *
 * The circuit breaker service is designed for use in the encrypted cloud backup protocol. More
 * information about encrypted cloud backup and the circuit breaker service can be found in the
 * official {@link https://docs.celo.org/celo-codebase/protocol/identity/encrypted-cloud-backup |
 * Celo documentation}
 */
export declare class CircuitBreakerClient {
    readonly environment: CircuitBreakerServiceContext;
    constructor(environment: CircuitBreakerServiceContext);
    protected url(endpoint: CircuitBreakerEndpoints): string;
    /**
     * Check the current status of the circuit breaker service. Result will reflect whether or not
     * the circuit breaker keys are currently available.
     */
    status(): Promise<Result<CircuitBreakerKeyStatus, CircuitBreakerError>>;
    /**
     * RSA-OAEP-256 Encrypt the provided key value against the public key of the circuit breaker.
     *
     * @remarks Note that this is an entirely local procedure and does not require interaction with
     * the circuit breaker service. Encryption occurs only against the service public key.
     */
    wrapKey(plaintext: Buffer): Result<Buffer, EncryptionError>;
    /** Request the circuit breaker service to decrypt the provided encrypted key value */
    unwrapKey(ciphertext: Buffer): Promise<Result<Buffer, CircuitBreakerError>>;
}
