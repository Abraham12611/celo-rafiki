/// <reference types="node" />
import { Result } from '@celo/base';
import { Address } from '@celo/utils/lib/address';
import { EIP712TypedData } from '@celo/utils/lib/sign-typed-data-utils';
import * as t from 'io-ts';
import { OffchainDataWrapper } from '../offchain-data-wrapper';
import { SchemaErrors } from './accessors/errors';
/**
 * Handles encrypting the data with a symmetric key, then distributing said key to each address
 * in the `toAddresses` array.
 *
 * @param wrapper the offchain data wrapper
 * @param dataPath path to where the encrypted data is stored. Used to derive the key location
 * @param data the data to encrypt
 * @param toAddresses the addresses to distribute the symmetric key to
 * @param symmetricKey the symmetric key to use to encrypt the data. One will be found or generated if not provided
 */
export declare const writeEncrypted: (wrapper: OffchainDataWrapper, dataPath: string, data: Buffer, toAddresses: Address[], symmetricKey?: Buffer) => Promise<SchemaErrors | void>;
export declare const writeSymmetricKeys: (wrapper: OffchainDataWrapper, dataPath: string, toAddresses: Address[], symmetricKey?: Buffer) => Promise<SchemaErrors | void>;
/**
 * Reads and decrypts a payload that has been encrypted to your data encryption key. Will
 * resolve the symmetric key used to encrypt the payload.
 *
 * @param wrapper the offchain data wrapper
 * @param dataPath path to where the encrypted data is stored. Used to derive the key location
 * @param senderAddress the address that encrypted this key to you
 */
export declare const readEncrypted: (wrapper: OffchainDataWrapper, dataPath: string, senderAddress: Address) => Promise<Result<Buffer, SchemaErrors>>;
export declare const deserialize: <DataType>(type: t.Type<DataType, DataType, unknown>, buf: Buffer) => Result<DataType, SchemaErrors>;
export declare const buildEIP712TypedData: <DataType>(wrapper: OffchainDataWrapper, path: string, data: Buffer | DataType, type?: t.Type<DataType, DataType, unknown> | undefined) => Promise<EIP712TypedData>;
export declare const signBuffer: (wrapper: OffchainDataWrapper, dataPath: string, buf: Buffer) => Promise<string>;
/**
 * We want users to be able to specify a root + path as their base
 * storage url, https://example.com/store-under/path, for example. Constructing
 * a URL doesn't respect these paths if the appended path is absolute, so we ensure
 * it's not and ensure the base is
 *
 * @param base root or base of the domain
 * @param path the path to append
 */
export declare function resolvePath(base: string, path: string): string;
