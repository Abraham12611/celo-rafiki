"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePath = exports.signBuffer = exports.buildEIP712TypedData = exports.deserialize = exports.readEncrypted = exports.writeSymmetricKeys = exports.writeEncrypted = void 0;
const base_1 = require("@celo/base");
const address_1 = require("@celo/utils/lib/address");
const ecdh_1 = require("@celo/utils/lib/ecdh");
const ecies_1 = require("@celo/utils/lib/ecies");
const crypto_1 = require("crypto");
const keccak_1 = require("ethereum-cryptography/keccak");
const utils_1 = require("ethereum-cryptography/utils");
const Either_1 = require("fp-ts/lib/Either");
const t = __importStar(require("io-ts"));
const path_1 = require("path");
const offchain_data_wrapper_1 = require("../offchain-data-wrapper");
const errors_1 = require("./accessors/errors");
const KEY_LENGTH = 16;
// label = PRF(ECDH(A, B), A || B || data path)
// ciphertext path = "/cosmetic path/" || base64(label)
function getCiphertextLabel(path, sharedSecret, senderPublicKey, receiverPublicKey) {
    const senderPublicKeyBuffer = Buffer.from((0, ecdh_1.ensureCompressed)(senderPublicKey), 'hex');
    const receiverPublicKeyBuffer = Buffer.from((0, ecdh_1.ensureCompressed)(receiverPublicKey), 'hex');
    const label = (0, crypto_1.createHmac)('sha256', sharedSecret)
        .update(Buffer.concat([senderPublicKeyBuffer, receiverPublicKeyBuffer, Buffer.from(path)]))
        .digest('hex');
    return (0, path_1.join)(path_1.sep, 'ciphertexts', label);
}
// Assumes that the wallet has the dataEncryptionKey of wrapper.self available
// TODO: Should check and throw a more meaningful error if not
/**
 * Encrypts the symmetric key `key` to `toAddress`'s data encryption key and uploads it
 * to the computed storage path.
 *
 * @param wrapper the offchain data wrapper
 * @param dataPath logical path for the data. Used to derive the key location
 * @param key the symmetric key to distribute
 * @param toAddress address to encrypt symmetric key to
 */
const distributeSymmetricKey = (wrapper, dataPath, key, toAddress) => __awaiter(void 0, void 0, void 0, function* () {
    const accounts = yield wrapper.kit.contracts.getAccounts();
    const [fromPubKey, toPubKey] = yield Promise.all([
        accounts.getDataEncryptionKey(wrapper.self),
        accounts.getDataEncryptionKey(toAddress),
    ]);
    if (fromPubKey === null) {
        return new errors_1.UnavailableKey(wrapper.self);
    }
    if (toPubKey === null) {
        return new errors_1.UnavailableKey(toAddress);
    }
    const wallet = wrapper.kit.getWallet();
    const sharedSecret = yield wallet.computeSharedSecret((0, address_1.publicKeyToAddress)(fromPubKey), toPubKey);
    const computedDataPath = getCiphertextLabel(`${dataPath}.key`, sharedSecret, fromPubKey, toPubKey);
    const encryptedData = (0, ecies_1.Encrypt)(Buffer.from((0, ecdh_1.trimUncompressedPrefix)((0, ecdh_1.ensureUncompressed)(toPubKey)), 'hex'), key);
    const signature = yield (0, exports.signBuffer)(wrapper, computedDataPath, encryptedData);
    const writeError = yield wrapper.writeDataTo(encryptedData, Buffer.from((0, base_1.trimLeading0x)(signature), 'hex'), computedDataPath);
    if (writeError) {
        return new errors_1.OffchainError(writeError);
    }
});
/**
 * Handles choosing the symmetric key to use.
 * If we're explicitly passing in a key, use that,
 * If a key has already been generated for this dataPath, use that,
 * Else generate a new one
 *
 * @param wrapper the offchain data wrapper
 * @param dataPath path to where the encrypted data is stored. Used to derive the key location
 * @param symmetricKey
 */
function fetchOrGenerateKey(wrapper, dataPath, symmetricKey) {
    return __awaiter(this, void 0, void 0, function* () {
        if (symmetricKey) {
            return (0, base_1.Ok)(symmetricKey);
        }
        const existingKey = yield readSymmetricKey(wrapper, dataPath, wrapper.self);
        if (existingKey.ok) {
            return (0, base_1.Ok)(existingKey.result);
        }
        if (existingKey.error.errorType === errors_1.SchemaErrorTypes.OffchainError &&
            (existingKey.error.error.errorType === offchain_data_wrapper_1.OffchainErrorTypes.NoStorageRootProvidedData ||
                existingKey.error.error.errorType === offchain_data_wrapper_1.OffchainErrorTypes.FetchError)) {
            return (0, base_1.Ok)((0, crypto_1.randomBytes)(16));
        }
        return (0, base_1.Err)(existingKey.error);
    });
}
/**
 * Handles encrypting the data with a symmetric key, then distributing said key to each address
 * in the `toAddresses` array.
 *
 * @param wrapper the offchain data wrapper
 * @param dataPath path to where the encrypted data is stored. Used to derive the key location
 * @param data the data to encrypt
 * @param toAddresses the addresses to distribute the symmetric key to
 * @param symmetricKey the symmetric key to use to encrypt the data. One will be found or generated if not provided
 */
const writeEncrypted = (wrapper, dataPath, data, toAddresses, symmetricKey) => __awaiter(void 0, void 0, void 0, function* () {
    const fetchKey = yield fetchOrGenerateKey(wrapper, dataPath, symmetricKey);
    if (!fetchKey.ok) {
        return fetchKey.error;
    }
    const iv = (0, crypto_1.randomBytes)(16);
    const payload = (0, ecies_1.AES128Encrypt)(fetchKey.result, iv, data);
    const signature = yield (0, exports.signBuffer)(wrapper, `${dataPath}.enc`, payload);
    const writeError = yield wrapper.writeDataTo(payload, Buffer.from((0, base_1.trimLeading0x)(signature), 'hex'), `${dataPath}.enc`);
    if (writeError) {
        return new errors_1.OffchainError(writeError);
    }
    const firstWriteError = (yield Promise.all(
    // here we encrypt the key to ourselves so we can retrieve it later
    [wrapper.self, ...toAddresses].map((toAddress) => __awaiter(void 0, void 0, void 0, function* () { return distributeSymmetricKey(wrapper, dataPath, fetchKey.result, toAddress); })))).find(Boolean);
    return firstWriteError;
});
exports.writeEncrypted = writeEncrypted;
const writeSymmetricKeys = (wrapper, dataPath, toAddresses, symmetricKey) => __awaiter(void 0, void 0, void 0, function* () {
    const fetchKey = yield fetchOrGenerateKey(wrapper, dataPath, symmetricKey);
    if (!fetchKey.ok) {
        return fetchKey.error;
    }
    const firstWriteError = (yield Promise.all(toAddresses.map((toAddress) => __awaiter(void 0, void 0, void 0, function* () { return distributeSymmetricKey(wrapper, dataPath, fetchKey.result, toAddress); })))).find(Boolean);
    return firstWriteError;
});
exports.writeSymmetricKeys = writeSymmetricKeys;
/**
 * Reads and decrypts a symmetric key that has been encrypted to your
 * data encryption key.
 *
 * @param wrapper the offchain data wrapper
 * @param dataPath path to where the encrypted data is stored. Used to derive the key location
 * @param senderAddress the address that encrypted this key to you
 */
const readSymmetricKey = (wrapper, dataPath, senderAddress) => __awaiter(void 0, void 0, void 0, function* () {
    const accounts = yield wrapper.kit.contracts.getAccounts();
    const wallet = wrapper.kit.getWallet();
    const [readerPubKey, senderPubKey] = yield Promise.all([
        accounts.getDataEncryptionKey(wrapper.self),
        accounts.getDataEncryptionKey(senderAddress),
    ]);
    if (readerPubKey === null) {
        return (0, base_1.Err)(new errors_1.UnavailableKey(wrapper.self));
    }
    if (senderPubKey === null) {
        return (0, base_1.Err)(new errors_1.UnavailableKey(senderAddress));
    }
    const readerPublicKeyAddress = (0, address_1.publicKeyToAddress)(readerPubKey);
    if (!wallet.hasAccount(readerPublicKeyAddress)) {
        return (0, base_1.Err)(new errors_1.UnavailableKey(readerPublicKeyAddress));
    }
    const sharedSecret = yield wallet.computeSharedSecret(readerPublicKeyAddress, senderPubKey);
    const computedDataPath = getCiphertextLabel(`${dataPath}.key`, sharedSecret, senderPubKey, readerPubKey);
    const encryptedPayload = yield wrapper.readDataFromAsResult(senderAddress, computedDataPath, true);
    if (!encryptedPayload.ok) {
        return (0, base_1.Err)(new errors_1.OffchainError(encryptedPayload.error));
    }
    const payload = yield wallet.decrypt(readerPublicKeyAddress, encryptedPayload.result);
    return (0, base_1.Ok)(payload);
});
/**
 * Reads and decrypts a payload that has been encrypted to your data encryption key. Will
 * resolve the symmetric key used to encrypt the payload.
 *
 * @param wrapper the offchain data wrapper
 * @param dataPath path to where the encrypted data is stored. Used to derive the key location
 * @param senderAddress the address that encrypted this key to you
 */
const readEncrypted = (wrapper, dataPath, senderAddress) => __awaiter(void 0, void 0, void 0, function* () {
    const encryptedPayloadPath = `${dataPath}.enc`;
    const [payload, key] = yield Promise.all([
        wrapper.readDataFromAsResult(senderAddress, encryptedPayloadPath, true),
        readSymmetricKey(wrapper, dataPath, senderAddress),
    ]);
    if (!payload.ok) {
        return (0, base_1.Err)(new errors_1.OffchainError(payload.error));
    }
    if (!key.ok) {
        return (0, base_1.Err)(key.error);
    }
    if (key.result.length !== KEY_LENGTH) {
        return (0, base_1.Err)(new errors_1.InvalidKey());
    }
    if (payload.result.length < ecies_1.IV_LENGTH) {
        return (0, base_1.Err)(new errors_1.InvalidDataError());
    }
    return (0, base_1.Ok)((0, ecies_1.AES128Decrypt)(key.result, payload.result.slice(0, ecies_1.IV_LENGTH), payload.result.slice(ecies_1.IV_LENGTH)));
});
exports.readEncrypted = readEncrypted;
const deserialize = (type, buf) => {
    const dataAsJson = (0, base_1.parseJsonAsResult)(buf.toString());
    if (!dataAsJson.ok) {
        return (0, base_1.Err)(new errors_1.InvalidDataError());
    }
    const parsedDataAsType = type.decode(dataAsJson.result);
    if ((0, Either_1.isLeft)(parsedDataAsType)) {
        return (0, base_1.Err)(new errors_1.InvalidDataError());
    }
    return (0, base_1.Ok)(parsedDataAsType.right);
};
exports.deserialize = deserialize;
const buildEIP712TypedData = (wrapper, path, data, type) => __awaiter(void 0, void 0, void 0, function* () {
    const chainId = yield wrapper.kit.connection.chainId();
    const EIP712Domain = [
        { name: 'name', type: 'string' },
        { name: 'version', type: 'string' },
        { name: 'chainId', type: 'uint256' },
    ];
    let types = {};
    let message = {};
    if (Buffer.isBuffer(data)) {
        types = {
            ClaimWithPath: [
                { name: 'path', type: 'string' },
                { name: 'hash', type: 'string' },
            ],
        };
        message = {
            hash: (0, base_1.ensureLeading0x)((0, utils_1.toHex)((0, keccak_1.keccak256)(data))),
        };
    }
    else {
        const Claim = buildEIP712Schema(type);
        types = {
            Claim,
            ClaimWithPath: [
                { name: 'path', type: 'string' },
                { name: 'payload', type: 'Claim' },
            ],
        };
        message = {
            payload: data,
        };
    }
    return {
        types: Object.assign({ EIP712Domain }, types),
        domain: {
            name: 'CIP8 Claim',
            version: '1.0.0',
            chainId,
        },
        primaryType: 'ClaimWithPath',
        message: Object.assign({ path }, message),
    };
});
exports.buildEIP712TypedData = buildEIP712TypedData;
const signBuffer = (wrapper, dataPath, buf) => __awaiter(void 0, void 0, void 0, function* () {
    const typedData = yield (0, exports.buildEIP712TypedData)(wrapper, dataPath, buf);
    return wrapper.kit.getWallet().signTypedData(wrapper.signer, typedData);
});
exports.signBuffer = signBuffer;
const ioTsToSolidityTypeMapping = {
    [t.string._tag]: 'string',
    [t.number._tag]: 'uint256',
    [t.boolean._tag]: 'bool',
};
const buildEIP712Schema = (type) => {
    // @ts-ignore
    const shape = type.props;
    // @ts-ignore
    return Object.entries(shape).reduce((accum, [key, value]) => {
        // @ts-ignore
        return [
            ...accum,
            {
                name: key,
                // @ts-ignore
                type: ioTsToSolidityTypeMapping[value._tag] || 'string',
            },
        ];
    }, []);
};
function ensureTrailingSeparator(str) {
    if (str[str.length - 1] !== '/') {
        return `${str}/`;
    }
    return str;
}
function trimLeadingSeparator(str) {
    if (str[0] === '/') {
        return str.slice(1);
    }
    return str;
}
/**
 * We want users to be able to specify a root + path as their base
 * storage url, https://example.com/store-under/path, for example. Constructing
 * a URL doesn't respect these paths if the appended path is absolute, so we ensure
 * it's not and ensure the base is
 *
 * @param base root or base of the domain
 * @param path the path to append
 */
function resolvePath(base, path) {
    return new URL(trimLeadingSeparator(path), ensureTrailingSeparator(base)).href;
}
exports.resolvePath = resolvePath;
