"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidKey = exports.UnavailableKey = exports.UnknownCiphertext = exports.OffchainError = exports.InvalidDataError = exports.SchemaErrorTypes = void 0;
const result_1 = require("@celo/base/lib/result");
var SchemaErrorTypes;
(function (SchemaErrorTypes) {
    SchemaErrorTypes["InvalidDataError"] = "InvalidDataError";
    SchemaErrorTypes["OffchainError"] = "OffchainError";
    SchemaErrorTypes["UnknownCiphertext"] = "UnknownCiphertext";
    SchemaErrorTypes["UnavailableKey"] = "UnavailableKey";
    SchemaErrorTypes["InvalidKey"] = "InvalidKey";
})(SchemaErrorTypes || (exports.SchemaErrorTypes = SchemaErrorTypes = {}));
class InvalidDataError extends result_1.RootError {
    constructor() {
        super(SchemaErrorTypes.InvalidDataError);
    }
}
exports.InvalidDataError = InvalidDataError;
class OffchainError extends result_1.RootError {
    constructor(error) {
        super(SchemaErrorTypes.OffchainError);
        this.error = error;
    }
}
exports.OffchainError = OffchainError;
class UnknownCiphertext extends result_1.RootError {
    constructor() {
        super(SchemaErrorTypes.UnknownCiphertext);
    }
}
exports.UnknownCiphertext = UnknownCiphertext;
class UnavailableKey extends result_1.RootError {
    constructor(account) {
        super(SchemaErrorTypes.UnavailableKey);
        this.account = account;
        this.message = `Unable to find account ${account}`;
    }
}
exports.UnavailableKey = UnavailableKey;
class InvalidKey extends result_1.RootError {
    constructor() {
        super(SchemaErrorTypes.InvalidKey);
    }
}
exports.InvalidKey = InvalidKey;
