/// <reference types="node" />
import { Address } from '@celo/base';
import { Result } from '@celo/base/lib/result';
import * as t from 'io-ts';
import { OffchainDataWrapper } from '../../offchain-data-wrapper';
import { InvalidDataError, OffchainError, SchemaErrors } from './errors';
import { PrivateAccessor, PublicAccessor } from './interfaces';
/**
 * A generic schema for reading and writing objects to and from storage. Passing
 * in a type parameter is supported for runtime type safety.
 */
export declare class PublicSimpleAccessor<DataType> implements PublicAccessor<DataType> {
    readonly wrapper: OffchainDataWrapper;
    readonly type: t.Type<DataType>;
    readonly dataPath: string;
    constructor(wrapper: OffchainDataWrapper, type: t.Type<DataType>, dataPath: string);
    private sign;
    write(data: DataType): Promise<InvalidDataError | OffchainError | undefined>;
    readAsResult(account: Address): Promise<Result<DataType, SchemaErrors>>;
    read: (account: string) => Promise<DataType>;
}
/**
 * A generic schema for writing and reading encrypted objects to and from storage. Passing
 * in a type parameter is supported for runtime type safety.
 */
export declare class PrivateSimpleAccessor<DataType> implements PrivateAccessor<DataType> {
    readonly wrapper: OffchainDataWrapper;
    readonly type: t.Type<DataType>;
    readonly dataPath: string;
    constructor(wrapper: OffchainDataWrapper, type: t.Type<DataType>, dataPath: string);
    write(data: DataType, toAddresses: Address[], symmetricKey?: Buffer): Promise<void | SchemaErrors>;
    allowAccess(toAddresses: Address[], symmetricKey?: Buffer): Promise<void | SchemaErrors>;
    readAsResult(account: Address): Promise<Result<DataType, SchemaErrors>>;
    read: (account: string) => Promise<DataType>;
}
