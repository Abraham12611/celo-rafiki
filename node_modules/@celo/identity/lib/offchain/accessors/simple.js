"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PrivateSimpleAccessor = exports.PublicSimpleAccessor = void 0;
const base_1 = require("@celo/base");
const result_1 = require("@celo/base/lib/result");
const utils_1 = require("../utils");
const errors_1 = require("./errors");
function serialize(data) {
    return Buffer.from(JSON.stringify(data));
}
/**
 * A generic schema for reading and writing objects to and from storage. Passing
 * in a type parameter is supported for runtime type safety.
 */
class PublicSimpleAccessor {
    constructor(wrapper, type, dataPath) {
        this.wrapper = wrapper;
        this.type = type;
        this.dataPath = dataPath;
        this.read = (0, result_1.makeAsyncThrowable)(this.readAsResult.bind(this));
    }
    sign(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const typedData = yield (0, utils_1.buildEIP712TypedData)(this.wrapper, this.dataPath, data, this.type);
            const wallet = this.wrapper.kit.getWallet();
            return wallet.signTypedData(this.wrapper.signer, typedData);
        });
    }
    write(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.type.is(data)) {
                return new errors_1.InvalidDataError();
            }
            const signature = yield this.sign(data);
            const error = yield this.wrapper.writeDataTo(serialize(data), Buffer.from((0, base_1.trimLeading0x)(signature), 'hex'), this.dataPath);
            if (error) {
                return new errors_1.OffchainError(error);
            }
        });
    }
    readAsResult(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const rawData = yield this.wrapper.readDataFromAsResult(account, this.dataPath, true, this.type);
            if (!rawData.ok) {
                return (0, result_1.Err)(new errors_1.OffchainError(rawData.error));
            }
            const deserializedResult = (0, utils_1.deserialize)(this.type, rawData.result);
            if (deserializedResult.ok) {
                return deserializedResult;
            }
            return deserializedResult;
        });
    }
}
exports.PublicSimpleAccessor = PublicSimpleAccessor;
/**
 * A generic schema for writing and reading encrypted objects to and from storage. Passing
 * in a type parameter is supported for runtime type safety.
 */
class PrivateSimpleAccessor {
    constructor(wrapper, type, dataPath) {
        this.wrapper = wrapper;
        this.type = type;
        this.dataPath = dataPath;
        this.read = (0, result_1.makeAsyncThrowable)(this.readAsResult.bind(this));
    }
    write(data, toAddresses, symmetricKey) {
        if (!this.type.is(data)) {
            return Promise.resolve(new errors_1.InvalidDataError());
        }
        return (0, utils_1.writeEncrypted)(this.wrapper, this.dataPath, serialize(data), toAddresses, symmetricKey);
    }
    allowAccess(toAddresses, symmetricKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.writeSymmetricKeys)(this.wrapper, this.dataPath, toAddresses, symmetricKey);
        });
    }
    readAsResult(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const encryptedResult = yield (0, utils_1.readEncrypted)(this.wrapper, this.dataPath, account);
            if (encryptedResult.ok) {
                return (0, utils_1.deserialize)(this.type, encryptedResult.result);
            }
            return encryptedResult;
        });
    }
}
exports.PrivateSimpleAccessor = PrivateSimpleAccessor;
