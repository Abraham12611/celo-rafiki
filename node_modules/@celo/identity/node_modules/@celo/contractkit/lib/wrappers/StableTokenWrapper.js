"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StableTokenWrapper = void 0;
const fixidity_1 = require("@celo/utils/lib/fixidity");
const BaseWrapper_1 = require("./BaseWrapper");
const CeloTokenWrapper_1 = require("./CeloTokenWrapper");
/**
 * Stable token with variable supply
 */
class StableTokenWrapper extends CeloTokenWrapper_1.CeloTokenWrapper {
    constructor() {
        super(...arguments);
        /**
         * Returns the address of the owner of the contract.
         * @return the address of the owner of the contract.
         */
        this.owner = (0, BaseWrapper_1.proxyCall)(this.contract.methods.owner);
        /**
         * Returns the units for a given value given the current inflation factor.
         * @param value The value to convert to units.
         * @return The units corresponding to `value` given the current inflation factor.
         * @dev We don't compute the updated inflationFactor here because
         * we assume any function calling this will have updated the inflation factor.
         */
        this.valueToUnits = (0, BaseWrapper_1.proxyCall)(this.contract.methods.valueToUnits, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString), BaseWrapper_1.valueToBigNumber);
        /**
         * Returns the value of a given number of units given the current inflation factor.
         * @param units The units to convert to value.
         * @return The value corresponding to `units` given the current inflation factor.
         */
        this.unitsToValue = (0, BaseWrapper_1.proxyCall)(this.contract.methods.unitsToValue, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.valueToString), BaseWrapper_1.valueToBigNumber);
        /**
         * Increases the allowance of another user.
         * @param spender The address which is being approved to spend StableToken.
         * @param value The increment of the amount of StableToken approved to the spender.
         * @returns true if success.
         */
        this.increaseAllowance = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.increaseAllowance, (0, BaseWrapper_1.tupleParser)(BaseWrapper_1.stringIdentity, BaseWrapper_1.valueToString));
        /**
         * Decreases the allowance of another user.
         * @param spender The address which is being approved to spend StableToken.
         * @param value The decrement of the amount of StableToken approved to the spender.
         * @returns true if success.
         */
        this.decreaseAllowance = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.decreaseAllowance);
        this.mint = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.mint);
        this.burn = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.burn);
        this.setInflationParameters = (0, BaseWrapper_1.proxySend)(this.connection, this.contract.methods.setInflationParameters);
    }
    /**
     * Querying the inflation parameters.
     * @returns Inflation rate, inflation factor, inflation update period and the last time factor was updated.
     */
    getInflationParameters() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.contract.methods.getInflationParameters().call();
            return {
                rate: (0, fixidity_1.fromFixed)((0, BaseWrapper_1.valueToBigNumber)(res[0])),
                factor: (0, fixidity_1.fromFixed)((0, BaseWrapper_1.valueToBigNumber)(res[1])),
                updatePeriod: (0, BaseWrapper_1.valueToBigNumber)(res[2]),
                factorLastUpdated: (0, BaseWrapper_1.valueToBigNumber)(res[3]),
            };
        });
    }
    /**
     * Returns current configuration parameters.
     */
    getConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield Promise.all([
                this.name(),
                this.symbol(),
                this.decimals(),
                this.getInflationParameters(),
            ]);
            return {
                name: res[0],
                symbol: res[1],
                decimals: res[2],
                inflationParameters: res[3],
            };
        });
    }
    /**
     * @dev Returns human readable configuration of the stabletoken contract
     * @return StableTokenConfig object
     */
    getHumanReadableConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.getConfig();
            const inflationParameters = Object.assign(Object.assign({}, config.inflationParameters), { updatePeriod: (0, BaseWrapper_1.secondsToDurationString)(config.inflationParameters.updatePeriod), factorLastUpdated: (0, BaseWrapper_1.unixSecondsTimestampToDateString)(config.inflationParameters.factorLastUpdated) });
            return Object.assign(Object.assign({}, config), { inflationParameters });
        });
    }
}
exports.StableTokenWrapper = StableTokenWrapper;
//# sourceMappingURL=StableTokenWrapper.js.map