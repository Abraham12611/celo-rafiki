import { EIP712Optional, EIP712TypedData } from '@celo/utils/lib/sign-typed-data-utils';
import * as t from 'io-ts';
import { KEY_VERSION_HEADER } from '..';
import { Domain, DomainOptions, SequentialDelayDomain } from '../domains';
export declare enum AuthenticationMethod {
    WALLET_KEY = "wallet_key",
    ENCRYPTION_KEY = "encryption_key"
}
export interface SignMessageRequest {
    /** Celo account address. Query is charged against this account's quota. */
    account: string;
    /** Query message. A blinded elliptic curve point encoded in base64. */
    blindedQueryPhoneNumber: string;
    /** Authentication method to use for verifying the signature in the Authorization header */
    authenticationMethod?: string;
    /** Client-specified session ID for the request. */
    sessionID?: string;
    /** Client-specified version string */
    version?: string;
}
export declare const SignMessageRequestSchema: t.Type<SignMessageRequest>;
export interface PnpQuotaRequest {
    account: string;
    /** Authentication method to use for verifying the signature in the Authorization header */
    authenticationMethod?: string;
    /** Client-specified session ID for the request. */
    sessionID?: string;
    /** Client-specified version string */
    version?: string;
}
export declare const PnpQuotaRequestSchema: t.Type<PnpQuotaRequest>;
export type PhoneNumberPrivacyRequest = SignMessageRequest | PnpQuotaRequest;
export declare enum DomainRequestTypeTag {
    SIGN = "DomainRestrictedSignatureRequest",
    QUOTA = "DomainQuotaStatusRequest",
    DISABLE = "DisableDomainRequest"
}
/**
 * Domain restricted signature request to get a pOPRF evaluation on the given message in a given
 * domain, as specified by CIP-40.
 *
 * @remarks Concrete request types are created by specifying the type parameter for Domain. If a
 * domain has no options, an empty struct should be used.
 */
export type DomainRestrictedSignatureRequest<D extends Domain = Domain> = {
    /** Request type tag to ensure this type can be distinguished from other request objects. */
    type: DomainRequestTypeTag.SIGN;
    /** Domain specification. Selects the PRF domain and rate limiting rules. */
    domain: D;
    /**
     * Domain-specific options.
     * Used for inputs relevant to the domain, but not part of the domain string.
     * Example: { "authorization": <signature> } for an account-restricted domain.
     */
    options: DomainOptions<D>;
    /** Query message. A blinded elliptic curve point encoded in base64. */
    blindedMessage: string;
    /** Client-specified session ID. */
    sessionID: EIP712Optional<string>;
};
/**
 * Request to get the quota status of the given domain. ODIS will respond with the current state
 * relevant to calculating quota under the associated rate limiting rules.
 *
 * Options may be provided for authentication in case the quota state is non-public information.
 * E.g. Quota state may reveal whether or not a user has attempted to recover a given account.
 *
 * @remarks Concrete request types are created by specifying the type parameter for Domain. If a
 * domain has no options, an empty struct should be used.
 */
export type DomainQuotaStatusRequest<D extends Domain = Domain> = {
    /** Request type tag to ensure this type can be distinguished from other request objects. */
    type: DomainRequestTypeTag.QUOTA;
    /** Domain specification. Selects the PRF domain and rate limiting rules. */
    domain: D;
    /** Domain-specific options. */
    options: DomainOptions<D>;
    /** Client-specified session ID. */
    sessionID: EIP712Optional<string>;
};
/**
 * Request to disable a domain such that not further requests for signatures in the given domain
 * will be served. Available for domains which need to option to prevent further requests for
 * security.
 *
 * Options may be provided for authentication to prevent unintended parties from disabling a domain.
 *
 * @remarks Concrete request types are created by specifying the type parameter for Domain. If a
 * domain has no options, an empty struct should be used.
 */
export type DisableDomainRequest<D extends Domain = Domain> = {
    /** Request type tag to ensure this type can be distinguished from other request objects. */
    type: DomainRequestTypeTag.DISABLE;
    /** Domain specification. Selects the PRF domain and rate limiting rules. */
    domain: D;
    /** Domain-specific options. */
    options: DomainOptions<D>;
    /** Client-specified session ID. */
    sessionID: EIP712Optional<string>;
};
/** Union type of Domain API requests */
export type DomainRequest<D extends Domain = Domain> = DomainRestrictedSignatureRequest<D> | DomainQuotaStatusRequest<D> | DisableDomainRequest<D>;
export type OdisRequest<D extends Domain = Domain> = DomainRequest<D> | PhoneNumberPrivacyRequest;
/** Parameterized schema for checking unknown input against DomainRestrictedSignatureRequest */
export declare function domainRestrictedSignatureRequestSchema<D extends Domain = Domain>(domain: t.Type<D>): t.Type<DomainRestrictedSignatureRequest<D>>;
/** Parameterized schema for checking unknown input against DomainQuotaStatusRequest */
export declare function domainQuotaStatusRequestSchema<D extends Domain = Domain>(domain: t.Type<D>): t.Type<DomainQuotaStatusRequest<D>>;
/** Parameterized schema for checking unknown input against DisableDomainRequest */
export declare function disableDomainRequestSchema<D extends Domain = Domain>(domain: t.Type<D>): t.Type<DisableDomainRequest<D>>;
/** Wraps the signature request as an EIP-712 typed data structure for hashing and signing */
export declare function domainRestrictedSignatureRequestEIP712<D extends Domain>(request: DomainRestrictedSignatureRequest<D>): EIP712TypedData;
/** Wraps the domain quota request as an EIP-712 typed data structure for hashing and signing */
export declare function domainQuotaStatusRequestEIP712<D extends Domain>(request: DomainQuotaStatusRequest<D>): EIP712TypedData;
/** Wraps the disable domain request as an EIP-712 typed data structure for hashing and signing */
export declare function disableDomainRequestEIP712<D extends Domain>(request: DisableDomainRequest<D>): EIP712TypedData;
/**
 * Verifies the authentication (e.g. client signature) over a domain signature request.
 * If the domain is unauthenticated, this function returns false.
 *
 * @remarks As specified in CIP-40, the signed message is the full request interpreted as EIP-712
 * typed data with the signature field in the domain options set to its zero value (i.e. It is set
 * to the undefined value for type EIP712Optional<string>).
 */
export declare function verifyDomainRestrictedSignatureRequestAuthenticity(request: DomainRestrictedSignatureRequest<SequentialDelayDomain>): boolean;
/**
 * Verifies the authentication (e.g. client signature) over a domain status request.
 * If the domain is unauthenticated, this function returns false.
 *
 * @remarks As specified in CIP-40, the signed message is the full request interpreted as EIP-712
 * typed data with the signature field in the domain options set to its zero value (i.e. It is set
 * to the undefined value for type EIP712Optional<string>).
 */
export declare function verifyDomainQuotaStatusRequestAuthenticity(request: DomainQuotaStatusRequest<SequentialDelayDomain>): boolean;
/**
 * Verifies the authentication (e.g. client signature) over a disable domain request.
 * If the domain is unauthenticated, this function returns false.
 *
 * @remarks As specified in CIP-40, the signed message is the full request interpreted as EIP-712
 * typed data with the signature field in the domain options set to its zero value (i.e. It is set
 * to the undefined value for type EIP712Optional<string>).
 */
export declare function verifyDisableDomainRequestAuthenticity(request: DisableDomainRequest<SequentialDelayDomain>): boolean;
interface PnpAuthHeader {
    Authorization: string;
}
interface KeyVersionHeader {
    [KEY_VERSION_HEADER]?: string;
}
export type DomainRestrictedSignatureRequestHeader = KeyVersionHeader;
export type DisableDomainRequestHeader = undefined;
export type DomainQuotaStatusRequestHeader = undefined;
export type DomainRequestHeader<R extends DomainRequest> = R extends DomainRestrictedSignatureRequest ? DomainRestrictedSignatureRequestHeader : never | R extends DisableDomainRequest ? DisableDomainRequestHeader : never | R extends DomainQuotaStatusRequest ? DomainQuotaStatusRequestHeader : never;
export type SignMessageRequestHeader = KeyVersionHeader & PnpAuthHeader;
export type PnpQuotaRequestHeader = PnpAuthHeader;
export type PhoneNumberPrivacyRequestHeader<R extends PhoneNumberPrivacyRequest> = R extends SignMessageRequest ? SignMessageRequestHeader : never | R extends PnpQuotaRequest ? PnpQuotaRequestHeader : never;
export type OdisRequestHeader<R extends OdisRequest> = R extends DomainRequest ? DomainRequestHeader<R> : never | R extends PhoneNumberPrivacyRequest ? PhoneNumberPrivacyRequestHeader<R> : never;
export {};
