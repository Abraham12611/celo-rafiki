"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyDisableDomainRequestAuthenticity = exports.verifyDomainQuotaStatusRequestAuthenticity = exports.verifyDomainRestrictedSignatureRequestAuthenticity = exports.disableDomainRequestEIP712 = exports.domainQuotaStatusRequestEIP712 = exports.domainRestrictedSignatureRequestEIP712 = exports.disableDomainRequestSchema = exports.domainQuotaStatusRequestSchema = exports.domainRestrictedSignatureRequestSchema = exports.DomainRequestTypeTag = exports.PnpQuotaRequestSchema = exports.SignMessageRequestSchema = exports.AuthenticationMethod = void 0;
const sign_typed_data_utils_1 = require("@celo/utils/lib/sign-typed-data-utils");
const signatureUtils_1 = require("@celo/utils/lib/signatureUtils");
const Either_1 = require("fp-ts/lib/Either");
const pipeable_1 = require("fp-ts/lib/pipeable");
const t = __importStar(require("io-ts"));
const __1 = require("..");
const domains_1 = require("../domains");
// Domain request types are only assignable to EIP712Object when using type instead
// of interface. Otherwise the compiler complains about a missing index signature.
var AuthenticationMethod;
(function (AuthenticationMethod) {
    AuthenticationMethod["WALLET_KEY"] = "wallet_key";
    AuthenticationMethod["ENCRYPTION_KEY"] = "encryption_key";
})(AuthenticationMethod || (exports.AuthenticationMethod = AuthenticationMethod = {}));
exports.SignMessageRequestSchema = t.intersection([
    t.type({
        account: t.string,
        blindedQueryPhoneNumber: t.string,
    }),
    t.partial({
        authenticationMethod: t.union([t.string, t.undefined]),
        sessionID: t.union([t.string, t.undefined]),
        version: t.union([t.string, t.undefined]),
    }),
]);
exports.PnpQuotaRequestSchema = t.intersection([
    t.type({
        account: t.string,
    }),
    t.partial({
        authenticationMethod: t.union([t.string, t.undefined]),
        sessionID: t.union([t.string, t.undefined]),
        version: t.union([t.string, t.undefined]),
    }),
]);
var DomainRequestTypeTag;
(function (DomainRequestTypeTag) {
    DomainRequestTypeTag["SIGN"] = "DomainRestrictedSignatureRequest";
    DomainRequestTypeTag["QUOTA"] = "DomainQuotaStatusRequest";
    DomainRequestTypeTag["DISABLE"] = "DisableDomainRequest";
})(DomainRequestTypeTag || (exports.DomainRequestTypeTag = DomainRequestTypeTag = {}));
// NOTE: Next three functions are a bit repetitive. An attempt was made to combine them, but the
// type signature got quite complicated. Feel free to attempt it if you are motivated.
/** Parameterized schema for checking unknown input against DomainRestrictedSignatureRequest */
function domainRestrictedSignatureRequestSchema(domain) {
    // The schema defined here does most of the work, but does not guarantee consistency between the
    // domain and options fields. We wrap the schema below to add a consistency check.
    const schema = t.strict({
        domain,
        type: t.literal(DomainRequestTypeTag.SIGN),
        options: t.unknown,
        blindedMessage: t.string,
        sessionID: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.string),
    });
    const validation = (unk, ctx) => (0, pipeable_1.pipe)(schema.validate(unk, ctx), (0, Either_1.chain)((value) => {
        if ((0, domains_1.isSequentialDelayDomain)(value.domain)) {
            const either = domains_1.SequentialDelayDomainOptionsSchema.validate(value.options, ctx);
            if ((0, Either_1.isRight)(either)) {
                return t.success(value);
            }
            return t.failure(unk, ctx, 'options type does not match domain type');
        }
        // canary provides a compile-time check that all subtypes of Domain have branches. If a case
        // was missed, then an error will report that domain cannot be assigned to type `never`.
        const canary = (x) => x;
        canary(value.domain);
        throw new Error('Implementation error: validated domain is not of any known type');
    }));
    return new t.Type(`DomainRestrictedSignatureRequestSchema<${domain.name}>`, (unk) => (0, Either_1.isRight)(validation(unk, [])), validation, (req) => req);
}
exports.domainRestrictedSignatureRequestSchema = domainRestrictedSignatureRequestSchema;
/** Parameterized schema for checking unknown input against DomainQuotaStatusRequest */
function domainQuotaStatusRequestSchema(domain) {
    // The schema defined here does most of the work, but does not guarantee consistency between the
    // domain and options fields. We wrap the schema below to add a consistency check.
    const schema = t.strict({
        domain,
        type: t.literal(DomainRequestTypeTag.QUOTA),
        options: t.unknown,
        sessionID: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.string),
    });
    const validation = (unk, ctx) => (0, pipeable_1.pipe)(schema.validate(unk, ctx), (0, Either_1.chain)((value) => {
        if ((0, domains_1.isSequentialDelayDomain)(value.domain)) {
            const either = domains_1.SequentialDelayDomainOptionsSchema.validate(value.options, ctx);
            if ((0, Either_1.isRight)(either)) {
                return t.success(value);
            }
            return t.failure(unk, ctx, 'options type does not match domain type');
        }
        // canary provides a compile-time check that all subtypes of Domain have branches. If a case
        // was missed, then an error will report that domain cannot be assigned to type `never`.
        const canary = (x) => x;
        canary(value.domain);
        throw new Error('Implementation error: validated domain is not of any known type');
    }));
    return new t.Type(`DomainQuotaStatusRequestSchema<${domain.name}>`, (unk) => (0, Either_1.isRight)(validation(unk, [])), validation, (req) => req);
}
exports.domainQuotaStatusRequestSchema = domainQuotaStatusRequestSchema;
/** Parameterized schema for checking unknown input against DisableDomainRequest */
function disableDomainRequestSchema(domain) {
    // The schema defined here does most of the work, but does not guarantee consistency between the
    // domain and options fields. We wrap the schema below to add a consistency check.
    const schema = t.strict({
        domain,
        type: t.literal(DomainRequestTypeTag.DISABLE),
        options: t.unknown,
        sessionID: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.string),
    });
    const validation = (unk, ctx) => (0, pipeable_1.pipe)(schema.validate(unk, ctx), (0, Either_1.chain)((value) => {
        if ((0, domains_1.isSequentialDelayDomain)(value.domain)) {
            const either = domains_1.SequentialDelayDomainOptionsSchema.validate(value.options, ctx);
            if ((0, Either_1.isRight)(either)) {
                return t.success(value);
            }
            return t.failure(unk, ctx, 'options type does not match domain type');
        }
        // canary provides a compile-time check that all subtypes of Domain have branches. If a case
        // was missed, then an error will report that domain cannot be assigned to type `never`.
        const canary = (x) => x;
        canary(value.domain);
        throw new Error('Implementation error: validated domain is not of any known type');
    }));
    return new t.Type(`DisableDomainRequestSchema<${domain.name}>`, (unk) => (0, Either_1.isRight)(validation(unk, [])), validation, (req) => req);
}
exports.disableDomainRequestSchema = disableDomainRequestSchema;
/** Wraps the signature request as an EIP-712 typed data structure for hashing and signing */
function domainRestrictedSignatureRequestEIP712(request) {
    const domainTypes = (0, domains_1.domainEIP712Types)(request.domain);
    const optionsTypes = (0, domains_1.domainOptionsEIP712Types)(request.domain);
    return {
        types: Object.assign(Object.assign(Object.assign(Object.assign({ DomainRestrictedSignatureRequest: [
                { name: 'type', type: 'string' },
                { name: 'blindedMessage', type: 'string' },
                { name: 'domain', type: domainTypes.primaryType },
                { name: 'options', type: optionsTypes.primaryType },
                { name: 'sessionID', type: 'Optional<string>' },
            ] }, domainTypes.types), optionsTypes.types), (0, sign_typed_data_utils_1.eip712OptionalType)('string')), { EIP712Domain: [
                { name: 'name', type: 'string' },
                { name: 'version', type: 'string' },
            ] }),
        primaryType: 'DomainRestrictedSignatureRequest',
        domain: {
            name: 'ODIS Domain Restricted Signature Request',
            version: '1',
        },
        message: request,
    };
}
exports.domainRestrictedSignatureRequestEIP712 = domainRestrictedSignatureRequestEIP712;
/** Wraps the domain quota request as an EIP-712 typed data structure for hashing and signing */
function domainQuotaStatusRequestEIP712(request) {
    const domainTypes = (0, domains_1.domainEIP712Types)(request.domain);
    const optionsTypes = (0, domains_1.domainOptionsEIP712Types)(request.domain);
    return {
        types: Object.assign(Object.assign(Object.assign(Object.assign({ DomainQuotaStatusRequest: [
                { name: 'type', type: 'string' },
                { name: 'domain', type: domainTypes.primaryType },
                { name: 'options', type: optionsTypes.primaryType },
                { name: 'sessionID', type: 'Optional<string>' },
            ] }, domainTypes.types), optionsTypes.types), (0, sign_typed_data_utils_1.eip712OptionalType)('string')), { EIP712Domain: [
                { name: 'name', type: 'string' },
                { name: 'version', type: 'string' },
            ] }),
        primaryType: 'DomainQuotaStatusRequest',
        domain: {
            name: 'ODIS Domain Quota Status',
            version: '1',
        },
        message: request,
    };
}
exports.domainQuotaStatusRequestEIP712 = domainQuotaStatusRequestEIP712;
/** Wraps the disable domain request as an EIP-712 typed data structure for hashing and signing */
function disableDomainRequestEIP712(request) {
    const domainTypes = (0, domains_1.domainEIP712Types)(request.domain);
    const optionsTypes = (0, domains_1.domainOptionsEIP712Types)(request.domain);
    return {
        types: Object.assign(Object.assign(Object.assign(Object.assign({ DisableDomainRequest: [
                { name: 'type', type: 'string' },
                { name: 'domain', type: domainTypes.primaryType },
                { name: 'options', type: optionsTypes.primaryType },
                { name: 'sessionID', type: 'Optional<string>' },
            ] }, domainTypes.types), optionsTypes.types), (0, sign_typed_data_utils_1.eip712OptionalType)('string')), { EIP712Domain: [
                { name: 'name', type: 'string' },
                { name: 'version', type: 'string' },
            ] }),
        primaryType: 'DisableDomainRequest',
        domain: {
            name: 'ODIS Disable Domain Request',
            version: '1',
        },
        message: request,
    };
}
exports.disableDomainRequestEIP712 = disableDomainRequestEIP712;
/**
 * Generic function to verify the signature on a Domain API request.
 *
 * @remarks Passing in the builder allows the caller to handle the differences of EIP-712 types
 * between request types. Requests cannot be fully differentiated at runtime. In particular,
 * DomainQuotaStatusRequest and DisableDomainRequest are indistinguishable at runtime.
 *
 * @privateRemarks Function is currently defined explicitly in terms of SequentialDelayDomain. It
 * should be generalized to other authenticated domain types as they are standardized.
 */
function verifyRequestSignature(typedDataBuilder, request) {
    // If the address field is undefined, then this domain is unauthenticated.
    // Return false as the signature cannot be checked.
    if (!request.domain.address.defined) {
        return false;
    }
    const signer = request.domain.address.value;
    // If not signature is provided, return false.
    if (!request.options.signature.defined) {
        return false;
    }
    const signature = request.options.signature.value;
    // Requests are signed over the message excluding the signature. CIP-40 specifies that the
    // signature in the signed message should be the zero value. When the signature type is
    // EIP712Optional<string>, this is { defined: false, value: "" } (i.e. `noString`)
    const message = Object.assign(Object.assign({}, request), { options: Object.assign(Object.assign({}, request.options), { signature: sign_typed_data_utils_1.noString }) });
    // Build the typed data then return the result of signature verification.
    const typedData = typedDataBuilder(message);
    return (0, signatureUtils_1.verifyEIP712TypedDataSigner)(typedData, signature, signer);
}
/**
 * Verifies the authentication (e.g. client signature) over a domain signature request.
 * If the domain is unauthenticated, this function returns false.
 *
 * @remarks As specified in CIP-40, the signed message is the full request interpreted as EIP-712
 * typed data with the signature field in the domain options set to its zero value (i.e. It is set
 * to the undefined value for type EIP712Optional<string>).
 */
function verifyDomainRestrictedSignatureRequestAuthenticity(request) {
    return verifyRequestSignature(domainRestrictedSignatureRequestEIP712, request);
}
exports.verifyDomainRestrictedSignatureRequestAuthenticity = verifyDomainRestrictedSignatureRequestAuthenticity;
/**
 * Verifies the authentication (e.g. client signature) over a domain status request.
 * If the domain is unauthenticated, this function returns false.
 *
 * @remarks As specified in CIP-40, the signed message is the full request interpreted as EIP-712
 * typed data with the signature field in the domain options set to its zero value (i.e. It is set
 * to the undefined value for type EIP712Optional<string>).
 */
function verifyDomainQuotaStatusRequestAuthenticity(request) {
    return verifyRequestSignature(domainQuotaStatusRequestEIP712, request);
}
exports.verifyDomainQuotaStatusRequestAuthenticity = verifyDomainQuotaStatusRequestAuthenticity;
/**
 * Verifies the authentication (e.g. client signature) over a disable domain request.
 * If the domain is unauthenticated, this function returns false.
 *
 * @remarks As specified in CIP-40, the signed message is the full request interpreted as EIP-712
 * typed data with the signature field in the domain options set to its zero value (i.e. It is set
 * to the undefined value for type EIP712Optional<string>).
 */
function verifyDisableDomainRequestAuthenticity(request) {
    return verifyRequestSignature(disableDomainRequestEIP712, request);
}
exports.verifyDisableDomainRequestAuthenticity = verifyDisableDomainRequestAuthenticity;
