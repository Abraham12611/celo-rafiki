import { EIP712Optional, EIP712TypesWithPrimary } from '@celo/utils/lib/sign-typed-data-utils';
import * as t from 'io-ts';
import { DomainIdentifiers } from './constants';
import { Domain } from './domains';
export type SequentialDelayStage = {
    /**
     * How many seconds each batch of attempts in this stage is delayed with
     * respect to the timer.
     */
    delay: number;
    /**
     * Whether the timer should be reset between attempts during this stage.
     * Defaults to true.
     */
    resetTimer: EIP712Optional<boolean>;
    /**
     * The number of continuous attempts a user gets before the next delay
     * in each repetition of this stage. Defaults to 1.
     */
    batchSize: EIP712Optional<number>;
    /**
     * The number of times this stage repeats before continuing to the next stage
     * in the RateLimit array. Defaults to 1.
     */
    repetitions: EIP712Optional<number>;
};
export type SequentialDelayDomain = {
    name: DomainIdentifiers.SequentialDelay;
    version: '1';
    stages: SequentialDelayStage[];
    /**
     * Optional Celo address against which signed requests must be authenticated.
     * In the case of Cloud Backup, this will be derived from a one-time key stored with the ciphertext.
     * Encoded as a checksummed address with leading "0x".
     */
    address: EIP712Optional<string>;
    /**
     * Optional string to distinguish the output of this domain instance from
     * other SequentialDelayDomain instances
     */
    salt: EIP712Optional<string>;
};
export type SequentialDelayDomainOptions = {
    /**
     * EIP-712 signature over the entire request by the address specified in the domain.
     * Required if `address` is defined in the domain instance. If `address` is
     * not defined in the domain instance, then a signature must not be provided.
     * Encoded as a hex string with leading 0x.
     */
    signature: EIP712Optional<string>;
    /**
     * Used to prevent replay attacks. Required if a signature is provided.
     * Code verifying the signature for rate limiting should check this nonce against a counter of
     * applied requests. E.g. Ensure the nonce is 0 on the first request and 2 on the third.
     */
    nonce: EIP712Optional<number>;
};
export interface SequentialDelayDomainState {
    /**
     * Timestamp in seconds since the Unix Epoch to which the next delay should be applied
     * to calculate when a new request will be accepted.
     */
    timer: number;
    /** Number of queries that have been accepted for the SequentialDelayDomain instance. */
    counter: number;
    /** Whether or not the domain has been disabled. If disabled, no more queries will be served. */
    disabled: boolean;
    /** Server timestamp in seconds since the Unix Epoch. */
    now: number;
}
export declare const INITIAL_SEQUENTIAL_DELAY_DOMAIN_STATE: SequentialDelayDomainState;
/** io-ts schema for encoding and decoding SequentialDelayStage structs */
export declare const SequentialDelayStageSchema: t.Type<SequentialDelayStage>;
/** io-ts schema for encoding and decoding SequentialDelayDomain structs */
export declare const SequentialDelayDomainSchema: t.Type<SequentialDelayDomain>;
/** io-ts schema for encoding and decoding SequentialDelayDomainOptions structs */
export declare const SequentialDelayDomainOptionsSchema: t.Type<SequentialDelayDomainOptions>;
/** io-ts schema for encoding and decoding SequentialDelayDomainState structs */
export declare const SequentialDelayDomainStateSchema: t.Type<SequentialDelayDomainState>;
export declare const isSequentialDelayDomain: (domain: Domain) => domain is SequentialDelayDomain;
export declare const sequentialDelayDomainEIP712Types: EIP712TypesWithPrimary;
export declare const sequentialDelayDomainOptionsEIP712Types: EIP712TypesWithPrimary;
/** Result values of the sequential delay domain rate limiting function */
export interface SequentialDelayResultAccepted {
    /** Whether or not a request will be accepted at the given time */
    accepted: true;
    /** State after applying an additional query against the quota */
    state: SequentialDelayDomainState;
}
export interface SequentialDelayResultRejected {
    /** Whether or not a request will be accepted at the given time */
    accepted: false;
    /** State after rejecting the request. Should be unchanged. */
    state: SequentialDelayDomainState;
    /**
     * Earliest time a request will be accepted at the current stage.
     * Undefined if a request will never be accepted.
     */
    notBefore?: number;
}
export type SequentialDelayResult = SequentialDelayResultAccepted | SequentialDelayResultRejected;
/**
 * Rate limiting predicate for the sequential delay domain
 *
 * @param domain SequentialDelayDomain instance against which the rate limit is being calculated,
 * and which supplied the rate limiting parameters.
 * @param attemptTime The Unix timestamp in seconds when the request was received.
 * @param state The current state of the domain, including the used quota counter and timer values.
 * Defaults to initial state if no state is available (i.e. for first request against the domain).
 */
export declare const checkSequentialDelayRateLimit: (domain: SequentialDelayDomain, attemptTime: number, state?: SequentialDelayDomainState) => SequentialDelayResult;
