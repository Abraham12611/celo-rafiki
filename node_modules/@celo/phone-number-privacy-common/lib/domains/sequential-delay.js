"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkSequentialDelayRateLimit = exports.sequentialDelayDomainOptionsEIP712Types = exports.sequentialDelayDomainEIP712Types = exports.isSequentialDelayDomain = exports.SequentialDelayDomainStateSchema = exports.SequentialDelayDomainOptionsSchema = exports.SequentialDelayDomainSchema = exports.SequentialDelayStageSchema = exports.INITIAL_SEQUENTIAL_DELAY_DOMAIN_STATE = void 0;
const sign_typed_data_utils_1 = require("@celo/utils/lib/sign-typed-data-utils");
const t = __importStar(require("io-ts"));
const constants_1 = require("./constants");
exports.INITIAL_SEQUENTIAL_DELAY_DOMAIN_STATE = {
    timer: 0,
    counter: 0,
    disabled: false,
    now: 0,
};
/** io-ts schema for encoding and decoding SequentialDelayStage structs */
exports.SequentialDelayStageSchema = t.strict({
    delay: t.number,
    resetTimer: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.boolean),
    batchSize: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.number),
    repetitions: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.number),
});
/** io-ts schema for encoding and decoding SequentialDelayDomain structs */
exports.SequentialDelayDomainSchema = t.strict({
    name: t.literal(constants_1.DomainIdentifiers.SequentialDelay),
    version: t.literal('1'),
    stages: t.array(exports.SequentialDelayStageSchema),
    address: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.string),
    salt: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.string),
});
/** io-ts schema for encoding and decoding SequentialDelayDomainOptions structs */
exports.SequentialDelayDomainOptionsSchema = t.strict({
    signature: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.string),
    nonce: (0, sign_typed_data_utils_1.eip712OptionalSchema)(t.number),
});
/** io-ts schema for encoding and decoding SequentialDelayDomainState structs */
exports.SequentialDelayDomainStateSchema = t.strict({
    timer: t.number,
    counter: t.number,
    disabled: t.boolean,
    now: t.number,
});
const isSequentialDelayDomain = (domain) => domain.name === constants_1.DomainIdentifiers.SequentialDelay && domain.version === '1';
exports.isSequentialDelayDomain = isSequentialDelayDomain;
exports.sequentialDelayDomainEIP712Types = {
    types: Object.assign(Object.assign(Object.assign(Object.assign({ SequentialDelayDomain: [
            { name: 'address', type: 'Optional<address>' },
            { name: 'name', type: 'string' },
            { name: 'salt', type: 'Optional<string>' },
            { name: 'stages', type: 'SequentialDelayStage[]' },
            { name: 'version', type: 'string' },
        ], SequentialDelayStage: [
            { name: 'batchSize', type: 'Optional<uint256>' },
            { name: 'delay', type: 'uint256' },
            { name: 'repetitions', type: 'Optional<uint256>' },
            { name: 'resetTimer', type: 'Optional<bool>' },
        ] }, (0, sign_typed_data_utils_1.eip712OptionalType)('address')), (0, sign_typed_data_utils_1.eip712OptionalType)('string')), (0, sign_typed_data_utils_1.eip712OptionalType)('uint256')), (0, sign_typed_data_utils_1.eip712OptionalType)('bool')),
    primaryType: 'SequentialDelayDomain',
};
exports.sequentialDelayDomainOptionsEIP712Types = {
    types: Object.assign(Object.assign({ SequentialDelayDomainOptions: [
            { name: 'nonce', type: 'Optional<uint256>' },
            { name: 'signature', type: 'Optional<string>' },
        ] }, (0, sign_typed_data_utils_1.eip712OptionalType)('string')), (0, sign_typed_data_utils_1.eip712OptionalType)('uint256')),
    primaryType: 'SequentialDelayDomainOptions',
};
/**
 * Rate limiting predicate for the sequential delay domain
 *
 * @param domain SequentialDelayDomain instance against which the rate limit is being calculated,
 * and which supplied the rate limiting parameters.
 * @param attemptTime The Unix timestamp in seconds when the request was received.
 * @param state The current state of the domain, including the used quota counter and timer values.
 * Defaults to initial state if no state is available (i.e. for first request against the domain).
 */
const checkSequentialDelayRateLimit = (domain, attemptTime, state = exports.INITIAL_SEQUENTIAL_DELAY_DOMAIN_STATE) => {
    // If the domain has been disabled, all queries are to be rejected.
    if (state.disabled) {
        return { accepted: false, state: Object.assign(Object.assign({}, state), { now: attemptTime }) };
    }
    const stage = getIndexedStage(domain, state.counter);
    // If the counter is past the last stage (i.e. the domain is permanently out of quota) return early.
    if (!stage) {
        return { accepted: false, state: Object.assign(Object.assign({}, state), { now: attemptTime }) };
    }
    const resetTimer = stage.resetTimer.defined ? stage.resetTimer.value : true;
    const delay = getDelay(stage, state.counter);
    const notBefore = state.timer + delay;
    if (attemptTime < notBefore) {
        return { accepted: false, notBefore, state: Object.assign(Object.assign({}, state), { now: attemptTime }) };
    }
    // Request is accepted. Update the state.
    return {
        accepted: true,
        state: {
            counter: state.counter + 1,
            timer: resetTimer ? attemptTime : notBefore,
            disabled: state.disabled,
            now: attemptTime,
        },
    };
};
exports.checkSequentialDelayRateLimit = checkSequentialDelayRateLimit;
/**
 * Finds the current stage of the SequentialDelayDomain rate limit for a given attempt number
 *
 * @param domain SequentialDelayDomain instance against which the rate limit is being calculated,
 * and which supplied the rate limiting parameters.
 * @param counter The current attempt number
 */
const getIndexedStage = (domain, counter) => {
    // The attempt index marking the beginning of the current stage
    let start = 0;
    // The index of the current stage in domain.stages[]
    let index = 0;
    // The number of attempts in the current stage
    let attemptsInStage = 0;
    while (start <= counter) {
        if (index >= domain.stages.length) {
            // Counter is past the last stage (i.e. the domain is permanently out of quota)
            return undefined;
        }
        const stage = domain.stages[index];
        const repetitions = stage.repetitions.defined ? stage.repetitions.value : 1;
        const batchSize = stage.batchSize.defined ? stage.batchSize.value : 1;
        attemptsInStage = repetitions * batchSize;
        start += attemptsInStage;
        index++;
    }
    start -= attemptsInStage;
    index--;
    return Object.assign(Object.assign({}, domain.stages[index]), { start });
};
/**
 * Finds the delay to enforce for an attempt given its counter (attempt number) and
 * the corresponding stage in the SequentialDelayDomain rate limit.
 *
 * @param stage IndexedSequentialDelayStage The given stage of the SequentialDelayDomain rate limit,
 * extended to include the index of the first attempt in that stage.
 * @param counter The current attempt number
 */
const getDelay = (stage, counter) => {
    const batchSize = stage.batchSize.defined ? stage.batchSize.value : 1;
    if ((counter - stage.start) % batchSize === 0) {
        return stage.delay;
    }
    return 0;
};
