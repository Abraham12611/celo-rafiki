"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.domainHash = exports.domainEIP712 = exports.domainOptionsEIP712Types = exports.domainEIP712Types = exports.DomainSchema = void 0;
const sign_typed_data_utils_1 = require("@celo/utils/lib/sign-typed-data-utils");
const sequential_delay_1 = require("./sequential-delay");
/** io-ts schema for encoding and decoding domains of any standardized type */
exports.DomainSchema = sequential_delay_1.SequentialDelayDomainSchema;
function domainEIP712Types(domain) {
    if ((0, sequential_delay_1.isSequentialDelayDomain)(domain)) {
        return sequential_delay_1.sequentialDelayDomainEIP712Types;
    }
    // canary provides a compile-time check that all subtypes of Domain have branches. If a case
    // was missed, then an error will report that domain cannot be assigned to type `never`.
    const canary = (x) => x;
    canary(domain);
    throw new Error('Implementation error. Input of type Domain was not recognized');
}
exports.domainEIP712Types = domainEIP712Types;
function domainOptionsEIP712Types(domain) {
    if ((0, sequential_delay_1.isSequentialDelayDomain)(domain)) {
        return sequential_delay_1.sequentialDelayDomainOptionsEIP712Types;
    }
    // canary provides a compile-time check that all subtypes of Domain have branches. If a case
    // was missed, then an error will report that domain cannot be assigned to type `never`.
    const canary = (x) => x;
    canary(domain);
    throw new Error('Implementation error. Input of type Domain was not recognized');
}
exports.domainOptionsEIP712Types = domainOptionsEIP712Types;
/**
 * Wraps a domain instance of a standardized type into an EIP-712 typed data structure, including
 * the EIP-712 type signature specififed by the mapping from TypeScript types in CIP-40.
 * https://github.com/celo-org/celo-proposals/blob/master/CIPs/cip-0040.md#mapping-typescript-to-eip-712-types
 */
const domainEIP712 = (domain) => ({
    types: Object.assign(Object.assign({}, domainEIP712Types(domain).types), { EIP712Domain: [
            { name: 'name', type: 'string' },
            { name: 'version', type: 'string' },
        ] }),
    primaryType: domainEIP712Types(domain).primaryType,
    domain: {
        name: domain.name,
        version: domain.version,
    },
    message: domain,
});
exports.domainEIP712 = domainEIP712;
/**
 * Produces the canonical 256-bit EIP-712 typed hash of the given domain.
 *
 * @remarks Note that this is a simple wrapper to get the EIP-712 hash after encoding it to an
 * EIP-712 typed data format. If a signature over the domain is needed, encode to EIP-712 format
 * and pass that into a signTypedData function.
 */
function domainHash(domain) {
    return (0, sign_typed_data_utils_1.generateTypedDataHash)((0, exports.domainEIP712)(domain));
}
exports.domainHash = domainHash;
