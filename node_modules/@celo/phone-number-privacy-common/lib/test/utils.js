"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPnpRequestAuthorization = exports.getPnpSignRequest = exports.getPnpQuotaRequest = exports.registerWalletAddress = exports.replenishQuota = exports.createMockWeb3 = exports.ContractRetrieval = exports.createMockConnection = exports.createMockContractKit = exports.createMockOdisPayments = exports.createMockAccounts = exports.createMockToken = exports.createMockAttestation = void 0;
const address_1 = require("@celo/utils/lib/address");
const signatureUtils_1 = require("@celo/utils/lib/signatureUtils");
const interfaces_1 = require("../interfaces");
const authentication_1 = require("../utils/authentication");
const logger_1 = require("../utils/logger");
function createMockAttestation(getVerifiedStatus) {
    return {
        getVerifiedStatus,
    };
}
exports.createMockAttestation = createMockAttestation;
function createMockToken(balanceOf) {
    return {
        balanceOf,
    };
}
exports.createMockToken = createMockToken;
function createMockAccounts(getWalletAddress, getDataEncryptionKey) {
    return {
        getWalletAddress,
        getDataEncryptionKey,
    };
}
exports.createMockAccounts = createMockAccounts;
// Take in jest.Mock to enable individual tests to spy on function calls
// and more easily set return values
function createMockOdisPayments(totalPaidCUSDFunc) {
    return {
        totalPaidCUSD: totalPaidCUSDFunc,
    };
}
exports.createMockOdisPayments = createMockOdisPayments;
function createMockContractKit(c, mockWeb3) {
    const contracts = {};
    for (const t of Object.keys(c)) {
        contracts[t] = jest.fn(() => c[t]);
    }
    return {
        contracts,
        registry: {
            addressFor: () => __awaiter(this, void 0, void 0, function* () { return 1000; }),
        },
        connection: mockWeb3 !== null && mockWeb3 !== void 0 ? mockWeb3 : createMockConnection(mockWeb3),
    };
}
exports.createMockContractKit = createMockContractKit;
function createMockConnection(mockWeb3) {
    return {
        web3: mockWeb3,
        getTransactionCount: jest.fn(() => mockWeb3.eth.getTransactionCount()),
        getBlockNumber: jest.fn(() => {
            return mockWeb3.eth.getBlockNumber();
        }),
    };
}
exports.createMockConnection = createMockConnection;
var ContractRetrieval;
(function (ContractRetrieval) {
    ContractRetrieval["getStableToken"] = "getStableToken";
    ContractRetrieval["getGoldToken"] = "getGoldToken";
    ContractRetrieval["getAccounts"] = "getAccounts";
    ContractRetrieval["getOdisPayments"] = "getOdisPayments";
})(ContractRetrieval || (exports.ContractRetrieval = ContractRetrieval = {}));
function createMockWeb3(txCount, blockNumber) {
    return {
        eth: {
            getTransactionCount: jest.fn(() => txCount),
            getBlockNumber: jest.fn(() => blockNumber),
        },
    };
}
exports.createMockWeb3 = createMockWeb3;
function replenishQuota(account, contractKit) {
    return __awaiter(this, void 0, void 0, function* () {
        const goldToken = yield contractKit.contracts.getGoldToken();
        const selfTransferTx = goldToken.transfer(account, 1);
        yield selfTransferTx.sendAndWaitForReceipt({ from: account });
    });
}
exports.replenishQuota = replenishQuota;
function registerWalletAddress(accountAddress, walletAddress, walletAddressPk, contractKit) {
    return __awaiter(this, void 0, void 0, function* () {
        const accounts = yield contractKit.contracts.getAccounts();
        const pop = yield accounts.generateProofOfKeyPossessionLocally(accountAddress, walletAddress, walletAddressPk);
        yield accounts
            .setWalletAddress(walletAddress, pop)
            .sendAndWaitForReceipt({ from: accountAddress });
    });
}
exports.registerWalletAddress = registerWalletAddress;
function getPnpQuotaRequest(account, authenticationMethod) {
    return {
        account,
        authenticationMethod,
        sessionID: (0, logger_1.genSessionID)(),
    };
}
exports.getPnpQuotaRequest = getPnpQuotaRequest;
function getPnpSignRequest(account, blindedQueryPhoneNumber, authenticationMethod) {
    return {
        account,
        blindedQueryPhoneNumber,
        authenticationMethod,
        sessionID: (0, logger_1.genSessionID)(),
    };
}
exports.getPnpSignRequest = getPnpSignRequest;
function getPnpRequestAuthorization(req, pk) {
    const msg = JSON.stringify(req);
    if (req.authenticationMethod === interfaces_1.AuthenticationMethod.ENCRYPTION_KEY) {
        return (0, authentication_1.signWithRawKey)(JSON.stringify(req), pk);
    }
    const account = (0, address_1.privateKeyToAddress)(pk);
    return (0, signatureUtils_1.serializeSignature)((0, signatureUtils_1.signMessage)(msg, pk, account));
}
exports.getPnpRequestAuthorization = getPnpRequestAuthorization;
