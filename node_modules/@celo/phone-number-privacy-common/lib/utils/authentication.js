"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDataEncryptionKey = exports.verifyDEKSignature = exports.signWithRawKey = exports.getMessageDigest = exports.authenticateUser = exports.newContractKitFetcher = void 0;
const base_1 = require("@celo/base");
const address_1 = require("@celo/utils/lib/address");
const signatureUtils_1 = require("@celo/utils/lib/signatureUtils");
const crypto_1 = __importDefault(require("crypto"));
const __1 = require("..");
const interfaces_1 = require("../interfaces");
const constants_1 = require("./constants");
function newContractKitFetcher(contractKit, logger, fullNodeTimeoutMs = constants_1.FULL_NODE_TIMEOUT_IN_MS, fullNodeRetryCount = constants_1.RETRY_COUNT, fullNodeRetryDelayMs = constants_1.RETRY_DELAY_IN_MS) {
    return (address) => getDataEncryptionKey(address, contractKit, logger, fullNodeTimeoutMs, fullNodeRetryCount, fullNodeRetryDelayMs);
}
exports.newContractKitFetcher = newContractKitFetcher;
/*
 * Confirms that user is who they say they are and throws error on failure to confirm.
 * Authorization header should contain the EC signed body
 */
function authenticateUser(request, logger, fetchDEK, warnings = []) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.debug('Authenticating user');
        // https://tools.ietf.org/html/rfc7235#section-4.2
        const messageSignature = request.get('Authorization');
        const message = JSON.stringify(request.body);
        const signer = request.body.account;
        const authMethod = request.body.authenticationMethod;
        if (!messageSignature || !signer) {
            return false;
        }
        if (authMethod && authMethod === interfaces_1.AuthenticationMethod.ENCRYPTION_KEY) {
            let registeredEncryptionKey;
            try {
                registeredEncryptionKey = yield fetchDEK(signer);
            }
            catch (err) {
                // getDataEncryptionKey should only throw if there is a full-node connection issue.
                // That is, it does not throw if the DEK is undefined or invalid
                logger.error({
                    err,
                    warning: interfaces_1.ErrorMessage.FAILURE_TO_GET_DEK,
                });
                warnings.push(interfaces_1.ErrorMessage.FAILURE_TO_GET_DEK);
                return false;
            }
            if (!registeredEncryptionKey) {
                logger.warn({ account: signer }, 'Account does not have registered encryption key');
                return false;
            }
            else {
                logger.info({ dek: registeredEncryptionKey, account: signer }, 'Found DEK for account');
                if (verifyDEKSignature(message, messageSignature, registeredEncryptionKey, logger)) {
                    return true;
                }
            }
        }
        // Fallback to previous signing pattern
        logger.info({ account: signer, message, messageSignature }, 'Message was not authenticated with DEK, attempting to authenticate using wallet key');
        // TODO This uses signature utils, why doesn't DEK authentication?
        // (https://github.com/celo-org/celo-monorepo/issues/9803)
        return (0, signatureUtils_1.verifySignature)(message, messageSignature, signer);
    });
}
exports.authenticateUser = authenticateUser;
function getMessageDigest(message) {
    // NOTE: Elliptic will truncate the raw msg to 64 bytes before signing,
    // so make sure to always pass the hex encoded msgDigest instead.
    return crypto_1.default.createHash('sha256').update(JSON.stringify(message)).digest('hex');
}
exports.getMessageDigest = getMessageDigest;
// Used primarily for signing requests with a DEK, counterpart of verifyDEKSignature
// For general signing, use SignatureUtils in @celo/utils
function signWithRawKey(msg, rawKey) {
    // NOTE: elliptic is disabled elsewhere in this library to prevent
    // accidental signing of truncated messages.
    const EC = require('elliptic').ec;
    const ec = new EC('secp256k1');
    // Sign
    const key = ec.keyFromPrivate((0, base_1.hexToBuffer)(rawKey));
    return JSON.stringify(key.sign(getMessageDigest(msg)).toDER());
}
exports.signWithRawKey = signWithRawKey;
function verifyDEKSignature(message, messageSignature, registeredEncryptionKey, logger) {
    logger = logger !== null && logger !== void 0 ? logger : (0, __1.rootLogger)((0, __1.fetchEnv)('SERVICE_NAME'));
    try {
        // NOTE: elliptic is disabled elsewhere in this library to prevent
        // accidental signing of truncated messages.
        const EC = require('elliptic').ec;
        const ec = new EC('secp256k1');
        const key = ec.keyFromPublic((0, address_1.trimLeading0x)(registeredEncryptionKey), 'hex');
        const parsedSig = JSON.parse(messageSignature);
        // TODO why do we use a different signing method instead of SignatureUtils?
        // (https://github.com/celo-org/celo-monorepo/issues/9803)
        if (key.verify(getMessageDigest(message), parsedSig)) {
            return true;
        }
        return false;
    }
    catch (err) {
        logger.error('Failed to verify signature with DEK');
        logger.error({ err, dek: registeredEncryptionKey });
        return false;
    }
}
exports.verifyDEKSignature = verifyDEKSignature;
function getDataEncryptionKey(address, contractKit, logger, fullNodeTimeoutMs, fullNodeRetryCount, fullNodeRetryDelayMs) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const res = yield (0, base_1.retryAsyncWithBackOffAndTimeout)(() => __awaiter(this, void 0, void 0, function* () {
                const accountWrapper = yield contractKit.contracts.getAccounts();
                return accountWrapper.getDataEncryptionKey(address);
            }), fullNodeRetryCount, [], fullNodeRetryDelayMs, 1.5, fullNodeTimeoutMs);
            return res;
        }
        catch (error) {
            logger.error('Failed to retrieve DEK: ' + error);
            logger.error(interfaces_1.ErrorMessage.FULL_NODE_ERROR);
            throw error;
        }
    });
}
exports.getDataEncryptionKey = getDataEncryptionKey;
