"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
const bunyan_1 = __importDefault(require("bunyan"));
const stream_1 = require("stream");
const Level2Severity = {
    [60 /* FATAL */]: 600 /* CRITICAL */,
    [50 /* ERROR */]: 500 /* ERROR */,
    [40 /* WARN */]: 400 /* WARNING */,
    [30 /* INFO */]: 200 /* INFO */,
    [20 /* DEBUG */]: 100 /* DEBUG */,
    [10 /* TRACE */]: 100 /* DEBUG */,
};
/**
 * TAKEN from bunyan source code. (but modified)
 *
 * A fast JSON.stringify that handles cycles and getter exceptions (when
 * safeJsonStringify is installed).
 *
 * This function attempts to use the regular JSON.stringify for speed, but on
 * error (e.g. JSON cycle detection exception) it falls back to safe stringify
 * handlers that can deal with cycles and/or getter exceptions.
 */
function fastAndSafeJsonStringify(rec) {
    try {
        return JSON.stringify(rec);
    }
    catch (ex) {
        try {
            return JSON.stringify(rec, bunyan_1.default.safeCycles());
        }
        catch (e) {
            return util_1.format('(Exception in JSON.stringify(rec): %j. ', e.message);
        }
    }
}
class StackdriverTransformer extends stream_1.Transform {
    constructor() {
        super({
            writableObjectMode: true,
        });
    }
    _transform(chunk, encoding, callback) {
        if (typeof chunk === 'string') {
            callback(new Error('Bad configuration. Use raw stream type on bunyan'));
            return;
        }
        let entry;
        try {
            entry = this.formatEntry(chunk);
        }
        catch (err) {
            callback(err);
            return;
        }
        callback(undefined, fastAndSafeJsonStringify(entry) + '\n');
    }
    /**
     * Format a bunyan record into a Stackdriver log entry.
     */
    formatEntry(record) {
        // extract field we want to transform or discard
        const { msg, level, err, req, v, hostname, pid } = record, others = __rest(record, ["msg", "level", "err", "req", "v", "hostname", "pid"]);
        const baseEntry = Object.assign({ message: msg, severity: Level2Severity[level] }, others);
        if (err && err.stack) {
            baseEntry.message = err.stack;
            baseEntry.serviceContext = {
                service: record.name,
            };
        }
        if (req) {
            baseEntry.httpRequest = req;
        }
        return baseEntry;
    }
}
exports.StackdriverTransformer = StackdriverTransformer;
function createStream(level, out) {
    const transformer = new StackdriverTransformer();
    transformer.pipe(out || process.stdout);
    return {
        level,
        type: 'raw',
        stream: transformer,
    };
}
exports.createStream = createStream;
